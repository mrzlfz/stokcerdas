/**
 * PHASE 7.1.1: Docker Container Configuration Interfaces üê≥
 * 
 * Comprehensive TypeScript interfaces untuk Docker container configuration,
 * deployment management, dan Indonesian infrastructure optimization.
 * Supports advanced container orchestration, microservices deployment,
 * security configuration, dan enterprise-grade container governance
 * dengan sophisticated Indonesian business context integration.
 */

// Extended interfaces not included in main service file

export interface ContainerConfigurationObjective {
  objectiveId: string;
  objectiveName: string;
  objectiveType: 'performance_objective' | 'security_objective' | 'deployment_objective' | 'resource_objective' | 'indonesian_objective';
  objectiveDescription: string;
  targetMetrics: ContainerTargetMetric[];
  successCriteria: ContainerSuccessCriterion[];
  businessJustification: string[];
  indonesianObjectiveFactors: string[];
}

export interface ContainerSuccessCriterion {
  criterionId: string;
  criterionName: string;
  criterionType: 'performance_criterion' | 'security_criterion' | 'deployment_criterion' | 'business_criterion';
  targetValue: number;
  measurementMethod: string;
  acceptanceThreshold: number;
  monitoringFrequency: string;
}

export interface ContainerOptimizationCriterion {
  criterionId: string;
  criterionName: string;
  criterionType: 'resource_optimization' | 'performance_optimization' | 'security_optimization' | 'deployment_optimization';
  optimizationTarget: number;
  currentValue: number;
  improvementPotential: number;
  optimizationStrategy: string[];
  indonesianOptimizationFactors: string[];
}

export interface ContainerDeploymentBaseline {
  baselineId: string;
  baselineName: string;
  baselineType: 'performance_baseline' | 'security_baseline' | 'resource_baseline' | 'deployment_baseline';
  baselineMetrics: ContainerBaselineMetric[];
  establishedDate: Date;
  validityPeriod: string;
  reviewFrequency: string;
  indonesianBaselineFactors: string[];
}

export interface ContainerBaselineMetric {
  metricId: string;
  metricName: string;
  metricType: 'performance' | 'security' | 'resource' | 'deployment' | 'business';
  baselineValue: number;
  measurementUnit: string;
  varianceThreshold: number;
  monitoringStrategy: string[];
}

export interface ContainerConfigurationComplexity {
  complexityLevel: 'low' | 'medium' | 'high' | 'enterprise' | 'indonesian_specific';
  complexityScore: number; // 0-100
  complexityFactors: ContainerComplexityFactor[];
  managementRequirements: ContainerManagementRequirement[];
  resourceImplications: ContainerResourceImplication[];
  indonesianComplexityFactors: string[];
}

export interface ContainerComplexityFactor {
  factorType: 'technical_complexity' | 'business_complexity' | 'security_complexity' | 'deployment_complexity';
  factorDescription: string;
  complexityContribution: number; // 0-100
  mitigationStrategies: string[];
  managementApproach: string[];
}

export interface ContainerManagementRequirement {
  requirementType: 'technical_management' | 'business_management' | 'security_management' | 'compliance_management';
  requirementDescription: string;
  managementLevel: 'basic' | 'intermediate' | 'advanced' | 'expert';
  skillRequirements: string[];
  toolRequirements: string[];
}

export interface ContainerResourceImplication {
  implicationType: 'compute_implication' | 'storage_implication' | 'network_implication' | 'management_implication';
  implicationDescription: string;
  resourceImpact: number; // percentage increase
  costImplication: number;
  scalabilityImpact: string[];
}

export interface IndonesianContainerPriority {
  priorityId: string;
  priorityName: string;
  priorityType: 'regulatory_priority' | 'business_priority' | 'cultural_priority' | 'technical_priority';
  priorityLevel: 'high' | 'medium' | 'low';
  priorityDescription: string;
  businessImpact: ContainerBusinessImpact;
  implementationRequirements: string[];
  complianceRequirements: string[];
}

export interface ContainerBusinessImpact {
  impactType: 'revenue_impact' | 'operational_impact' | 'compliance_impact' | 'customer_impact';
  impactDescription: string;
  impactMagnitude: number; // 0-100
  impactTimeframe: string;
  mitigationStrategies: string[];
}

export interface IndonesianContainerScenarioFactor {
  factorId: string;
  factorName: string;
  factorType: 'regulatory_factor' | 'cultural_factor' | 'business_factor' | 'technical_factor';
  factorDescription: string;
  scenarioImpact: ContainerScenarioImpact[];
  adaptationRequirements: string[];
  validationCriteria: string[];
}

export interface ContainerScenarioImpact {
  impactArea: 'deployment' | 'performance' | 'security' | 'compliance' | 'business';
  impactDescription: string;
  impactSeverity: 'low' | 'medium' | 'high' | 'critical';
  mitigationStrategy: string[];
  monitoringRequirements: string[];
}

export interface ContainerValidation {
  validationId: string;
  validationType: 'technical_validation' | 'business_validation' | 'security_validation' | 'compliance_validation';
  validationDescription: string;
  validationCriteria: ContainerValidationCriterion[];
  validationMethods: ContainerValidationMethod[];
  expectedResults: ContainerValidationResult[];
  indonesianValidationFactors: string[];
}

export interface ContainerValidationCriterion {
  criterionId: string;
  criterionName: string;
  criterionType: 'functional_criterion' | 'performance_criterion' | 'security_criterion' | 'compliance_criterion';
  validationLogic: string;
  acceptanceCriteria: string[];
  testingApproach: string[];
}

export interface ContainerValidationMethod {
  methodId: string;
  methodName: string;
  methodType: 'automated_testing' | 'manual_testing' | 'monitoring_validation' | 'compliance_audit';
  methodDescription: string;
  executionFrequency: string;
  toolRequirements: string[];
}

export interface ContainerValidationResult {
  resultId: string;
  validationType: string;
  validationStatus: 'passed' | 'failed' | 'warning' | 'not_applicable';
  validationScore: number; // 0-100
  validationDetails: string;
  recommendedActions: string[];
  complianceStatus: string;
}

// Docker Container Management Specific Interfaces

export interface DockerContainerManagement {
  managementId: string;
  managementScope: DockerManagementScope;
  containerOrchestration: ContainerOrchestration;
  containerLifecycleManagement: ContainerLifecycleManagement;
  containerImageManagement: ContainerImageManagement;
  containerRegistryManagement: ContainerRegistryManagement;
  dockerEngineConfiguration: DockerEngineConfiguration;
  containerNetworkManagement: ContainerNetworkManagement;
  containerVolumeManagement: ContainerVolumeManagement;
  indonesianDockerConfiguration: IndonesianDockerConfiguration;
}

export interface DockerManagementScope {
  scopeType: 'development' | 'staging' | 'production' | 'disaster_recovery' | 'indonesian_deployment';
  managementLevel: 'basic' | 'intermediate' | 'advanced' | 'enterprise';
  containerCount: number;
  serviceCount: number;
  environmentCount: number;
  managementComplexity: number; // 0-100
}

export interface ContainerOrchestration {
  orchestrationPlatform: 'docker_compose' | 'docker_swarm' | 'kubernetes' | 'hybrid';
  orchestrationStrategy: ContainerOrchestrationStrategy;
  serviceDiscovery: ContainerServiceDiscovery;
  loadBalancing: ContainerLoadBalancing;
  autoScaling: ContainerAutoScaling;
  healthChecking: ContainerHealthChecking;
}

export interface ContainerOrchestrationStrategy {
  strategyType: 'single_host' | 'multi_host' | 'cloud_native' | 'hybrid_cloud' | 'indonesian_multi_region';
  deploymentPattern: 'blue_green' | 'rolling' | 'canary' | 'a_b_testing';
  rollbackStrategy: string[];
  scalingStrategy: string[];
  failoverStrategy: string[];
}

export interface ContainerServiceDiscovery {
  discoveryMechanism: 'dns' | 'service_mesh' | 'load_balancer' | 'registry_based';
  serviceRegistration: ContainerServiceRegistration;
  healthMonitoring: ContainerHealthMonitoring;
  serviceRouting: ContainerServiceRouting;
}

export interface ContainerServiceRegistration {
  registrationMethod: 'automatic' | 'manual' | 'api_driven';
  registrationMetadata: ContainerRegistrationMetadata[];
  deregistrationPolicy: string[];
  heartbeatConfiguration: ContainerHeartbeatConfig;
}

export interface ContainerRegistrationMetadata {
  metadataType: 'service_metadata' | 'health_metadata' | 'routing_metadata' | 'business_metadata';
  metadataKey: string;
  metadataValue: any;
  metadataSource: string;
  updateFrequency: string;
}

export interface ContainerHeartbeatConfig {
  heartbeatInterval: number; // seconds
  timeoutThreshold: number; // seconds
  maxRetries: number;
  failureAction: 'deregister' | 'mark_unhealthy' | 'alert_only';
}

export interface ContainerHealthMonitoring {
  monitoringType: 'passive' | 'active' | 'hybrid';
  healthCheckEndpoints: ContainerHealthEndpoint[];
  monitoringMetrics: ContainerMonitoringMetric[];
  alertingConfiguration: ContainerAlertConfig;
}

export interface ContainerHealthEndpoint {
  endpointPath: string;
  endpointMethod: 'GET' | 'POST' | 'HEAD';
  expectedResponseCode: number;
  timeoutSeconds: number;
  checkInterval: number;
}

export interface ContainerMonitoringMetric {
  metricName: string;
  metricType: 'gauge' | 'counter' | 'histogram' | 'summary';
  metricSource: string;
  collectionInterval: number;
  thresholds: ContainerMetricThreshold[];
}

export interface ContainerMetricThreshold {
  thresholdType: 'warning' | 'critical' | 'fatal';
  thresholdValue: number;
  comparisonOperator: 'gt' | 'lt' | 'eq' | 'gte' | 'lte';
  actionRequired: string[];
}

export interface ContainerAlertConfig {
  alertingEnabled: boolean;
  alertChannels: ContainerAlertChannel[];
  alertEscalation: ContainerAlertEscalation;
  suppressionRules: ContainerAlertSuppression[];
}

export interface ContainerAlertChannel {
  channelType: 'email' | 'slack' | 'webhook' | 'sms' | 'indonesian_notification';
  channelConfiguration: any;
  alertSeverity: string[];
  messageTemplate: string;
}

export interface ContainerAlertEscalation {
  escalationEnabled: boolean;
  escalationLevels: ContainerEscalationLevel[];
  escalationTimeout: number; // minutes
  escalationCriteria: string[];
}

export interface ContainerEscalationLevel {
  levelNumber: number;
  levelName: string;
  recipients: string[];
  escalationDelay: number; // minutes
  actionRequired: string[];
}

export interface ContainerAlertSuppression {
  suppressionRule: string;
  suppressionWindow: ContainerSuppressionWindow;
  suppressionConditions: string[];
  overrideConditions: string[];
}

export interface ContainerSuppressionWindow {
  windowType: 'time_based' | 'event_based' | 'condition_based';
  windowStart: Date;
  windowEnd: Date;
  windowDuration: number; // minutes
  recurrencePattern: string;
}

export interface ContainerServiceRouting {
  routingStrategy: 'round_robin' | 'least_connections' | 'ip_hash' | 'weighted' | 'indonesian_geo_routing';
  routingRules: ContainerRoutingRule[];
  routingHealthChecks: boolean;
  routingMetrics: ContainerRoutingMetric[];
}

export interface ContainerRoutingRule {
  ruleId: string;
  ruleName: string;
  ruleType: 'path_based' | 'header_based' | 'geo_based' | 'weight_based';
  ruleCondition: string;
  ruleAction: ContainerRoutingAction;
  rulePriority: number;
}

export interface ContainerRoutingAction {
  actionType: 'forward' | 'redirect' | 'reject' | 'modify';
  targetService: string;
  actionParameters: any;
  actionMetadata: ContainerActionMetadata[];
}

export interface ContainerActionMetadata {
  metadataKey: string;
  metadataValue: any;
  metadataType: 'routing' | 'transformation' | 'logging' | 'monitoring';
}

export interface ContainerRoutingMetric {
  metricName: string;
  metricDescription: string;
  metricCollection: boolean;
  metricAggregation: string[];
  metricRetention: number; // days
}

export interface ContainerLoadBalancing {
  loadBalancerType: 'application' | 'network' | 'global' | 'indonesian_regional';
  loadBalancingAlgorithm: string;
  healthCheckConfiguration: ContainerHealthCheckConfig;
  sessionAffinity: ContainerSessionAffinity;
  sslTermination: ContainerSslTermination;
}

export interface ContainerHealthCheckConfig {
  healthCheckEnabled: boolean;
  healthCheckPath: string;
  healthCheckInterval: number; // seconds
  healthCheckTimeout: number; // seconds
  healthyThreshold: number;
  unhealthyThreshold: number;
}

export interface ContainerSessionAffinity {
  affinityEnabled: boolean;
  affinityType: 'cookie' | 'ip' | 'header';
  affinityDuration: number; // seconds
  affinityConfiguration: any;
}

export interface ContainerSslTermination {
  sslEnabled: boolean;
  sslCertificateSource: 'managed' | 'imported' | 'self_signed';
  sslPolicies: string[];
  sslRedirection: boolean;
}

export interface ContainerAutoScaling {
  autoScalingEnabled: boolean;
  scalingMetrics: ContainerScalingMetric[];
  scalingPolicies: ContainerScalingPolicy[];
  scalingLimits: ContainerScalingLimits;
  indonesianScalingFactors: IndonesianScalingFactor[];
}

export interface ContainerScalingMetric {
  metricName: string;
  metricType: 'cpu' | 'memory' | 'network' | 'custom' | 'business';
  targetValue: number;
  aggregationMethod: 'average' | 'maximum' | 'minimum' | 'sum';
  evaluationPeriod: number; // seconds
}

export interface ContainerScalingPolicy {
  policyName: string;
  policyType: 'scale_up' | 'scale_down';
  triggerCondition: string;
  scalingAction: ContainerScalingAction;
  cooldownPeriod: number; // seconds
}

export interface ContainerScalingAction {
  actionType: 'change_capacity' | 'percentage_change' | 'exact_capacity';
  scalingAdjustment: number;
  adjustmentType: 'absolute' | 'percentage' | 'exact';
  minAdjustmentStep: number;
}

export interface ContainerScalingLimits {
  minimumCapacity: number;
  maximumCapacity: number;
  desiredCapacity: number;
  scalingGracePeriod: number; // seconds
}

export interface IndonesianScalingFactor {
  factorType: 'business_hours' | 'cultural_events' | 'regional_demand' | 'regulatory_requirements';
  factorDescription: string;
  scalingImpact: number; // percentage
  temporalPattern: string;
  adjustmentStrategy: string[];
}

export interface ContainerHealthChecking {
  healthCheckStrategy: 'liveness' | 'readiness' | 'startup' | 'comprehensive';
  healthCheckImplementation: ContainerHealthCheckImplementation[];
  healthCheckReporting: ContainerHealthCheckReporting;
  healthCheckActions: ContainerHealthCheckAction[];
}

export interface ContainerHealthCheckImplementation {
  checkType: 'http' | 'tcp' | 'command' | 'script';
  checkConfiguration: any;
  checkFrequency: number; // seconds
  checkTimeout: number; // seconds
  failureThreshold: number;
  successThreshold: number;
}

export interface ContainerHealthCheckReporting {
  reportingEnabled: boolean;
  reportingFormat: 'json' | 'xml' | 'plain_text';
  reportingDestination: string[];
  reportingFrequency: number; // seconds
}

export interface ContainerHealthCheckAction {
  actionTrigger: 'failure' | 'success' | 'degraded' | 'recovered';
  actionType: 'restart' | 'stop' | 'alert' | 'log' | 'indonesian_notification';
  actionConfiguration: any;
  actionDelay: number; // seconds
}

// Results Interfaces

export interface DockerContainerResult {
  resultId: string;
  containerName: string;
  containerStatus: 'running' | 'stopped' | 'failed' | 'pending';
  containerMetrics: ContainerMetric[];
  containerHealth: ContainerHealth;
  deploymentInfo: ContainerDeploymentInfo;
  indonesianCompliance: IndonesianContainerCompliance;
}

export interface ContainerMetric {
  metricName: string;
  metricValue: number;
  metricUnit: string;
  metricTimestamp: Date;
  metricTrend: 'increasing' | 'decreasing' | 'stable';
}

export interface ContainerHealth {
  healthStatus: 'healthy' | 'unhealthy' | 'degraded' | 'unknown';
  healthScore: number; // 0-100
  healthChecks: ContainerHealthCheck[];
  lastHealthUpdate: Date;
}

export interface ContainerHealthCheck {
  checkName: string;
  checkStatus: 'passed' | 'failed' | 'warning';
  checkMessage: string;
  checkTimestamp: Date;
}

export interface ContainerDeploymentInfo {
  deploymentId: string;
  deploymentStrategy: string;
  deploymentTimestamp: Date;
  deploymentStatus: 'successful' | 'failed' | 'in_progress' | 'rolled_back';
  deploymentMetrics: ContainerDeploymentMetric[];
}

export interface ContainerDeploymentMetric {
  metricName: string;
  metricValue: any;
  metricDescription: string;
  metricCategory: 'performance' | 'resource' | 'business' | 'indonesian';
}

export interface IndonesianContainerCompliance {
  complianceStatus: 'compliant' | 'non_compliant' | 'partially_compliant' | 'under_review';
  complianceScore: number; // 0-100
  complianceAreas: IndonesianComplianceArea[];
  complianceValidation: Date;
}

export interface IndonesianComplianceArea {
  areaName: string;
  areaType: 'data_residency' | 'regulatory' | 'cultural' | 'business';
  complianceLevel: number; // 0-100
  complianceDetails: string[];
  improvementActions: string[];
}

export interface MicroservicesContainerResult {
  serviceId: string;
  serviceName: string;
  containerizationStatus: 'containerized' | 'in_progress' | 'failed' | 'not_started';
  serviceMetrics: MicroserviceMetric[];
  serviceHealth: MicroserviceHealth;
  serviceDependencies: MicroserviceDependency[];
}

export interface MicroserviceMetric {
  metricType: 'performance' | 'resource' | 'business' | 'technical';
  metricName: string;
  metricValue: number;
  metricUnit: string;
  metricTrend: string;
}

export interface MicroserviceHealth {
  healthOverall: number; // 0-100
  healthComponents: MicroserviceHealthComponent[];
  healthTrend: 'improving' | 'degrading' | 'stable';
  lastHealthCheck: Date;
}

export interface MicroserviceHealthComponent {
  componentName: string;
  componentHealth: number; // 0-100
  componentStatus: string;
  componentIssues: string[];
}

export interface MicroserviceDependency {
  dependencyName: string;
  dependencyType: 'service' | 'database' | 'cache' | 'external_api';
  dependencyStatus: 'available' | 'unavailable' | 'degraded';
  dependencyMetrics: any[];
}

export interface ContainerResourceResult {
  resourceType: 'cpu' | 'memory' | 'storage' | 'network';
  resourceUtilization: number; // percentage
  resourceLimits: ContainerResourceLimit;
  resourceOptimization: ContainerResourceOptimization;
  resourceRecommendations: string[];
}

export interface ContainerResourceLimit {
  currentLimit: number;
  recommendedLimit: number;
  limitUnit: string;
  limitJustification: string[];
}

export interface ContainerResourceOptimization {
  optimizationLevel: number; // 0-100
  optimizationOpportunities: string[];
  optimizationImpact: number; // percentage improvement
  optimizationComplexity: 'low' | 'medium' | 'high';
}

export interface ContainerSecurityResult {
  securityLevel: 'low' | 'medium' | 'high' | 'enterprise';
  securityScore: number; // 0-100
  securityVulnerabilities: ContainerSecurityVulnerability[];
  securityCompliance: ContainerSecurityCompliance;
  securityRecommendations: string[];
}

export interface ContainerSecurityVulnerability {
  vulnerabilityId: string;
  vulnerabilityType: 'image' | 'configuration' | 'runtime' | 'network';
  severityLevel: 'low' | 'medium' | 'high' | 'critical';
  vulnerabilityDescription: string;
  mitigationSteps: string[];
}

export interface ContainerSecurityCompliance {
  complianceFramework: string[];
  complianceLevel: number; // 0-100
  complianceGaps: string[];
  complianceActions: string[];
}

export interface ContainerNetworkingResult {
  networkConfiguration: ContainerNetworkConfig;
  networkPerformance: ContainerNetworkPerformance;
  networkSecurity: ContainerNetworkSecurity;
  networkOptimization: string[];
}

export interface ContainerNetworkConfig {
  networkType: 'bridge' | 'host' | 'overlay' | 'custom';
  networkPolicies: string[];
  networkSegmentation: boolean;
  networkEncryption: boolean;
}

export interface ContainerNetworkPerformance {
  latencyAverage: number; // milliseconds
  throughputAverage: number; // mbps
  packetLoss: number; // percentage
  performanceGrade: 'excellent' | 'good' | 'fair' | 'poor';
}

export interface ContainerNetworkSecurity {
  securityPolicies: string[];
  trafficEncryption: boolean;
  accessControl: boolean;
  threatDetection: boolean;
}

export interface ContainerMonitoringResult {
  monitoringCoverage: number; // percentage
  monitoringMetrics: ContainerMonitoringMetricResult[];
  monitoringAlerts: ContainerMonitoringAlert[];
  monitoringRecommendations: string[];
}

export interface ContainerMonitoringMetricResult {
  metricName: string;
  metricValue: number;
  metricStatus: 'normal' | 'warning' | 'critical';
  metricTrend: string;
}

export interface ContainerMonitoringAlert {
  alertId: string;
  alertType: 'performance' | 'security' | 'resource' | 'business';
  alertSeverity: 'low' | 'medium' | 'high' | 'critical';
  alertMessage: string;
  alertTimestamp: Date;
}

export interface ContainerConfigurationMetadata {
  configurationVersion: string;
  configurationFramework: string;
  dockerVersion: string;
  kubernetesVersion?: string;
  indonesianCompliance: boolean;
  enterpriseFeatures: string[];
  supportLevel: 'basic' | 'standard' | 'premium' | 'enterprise';
}

// Microservices Containerization Interfaces

export interface MicroservicesContainerization {
  containerizationId: string;
  containerizationScope: MicroservicesContainerizationScope;
  serviceContainerization: ServiceContainerization;
  containerImageOptimization: ContainerImageOptimization;
  serviceDiscoveryContainerization: ServiceDiscoveryContainerization;
  apiGatewayContainerization: ApiGatewayContainerization;
  dataServiceContainerization: DataServiceContainerization;
  mlServiceContainerization: MLServiceContainerization;
  indonesianMicroservicesConfiguration: IndonesianMicroservicesConfiguration;
}

export interface MicroservicesContainerizationScope {
  scopeType: 'full_containerization' | 'selective_containerization' | 'hybrid_approach' | 'indonesian_optimized';
  serviceCount: number;
  containerizationStrategy: string;
  complexityLevel: number; // 0-100
  businessPriority: 'high' | 'medium' | 'low';
}

export interface ServiceContainerization {
  containerizationApproach: 'single_container_per_service' | 'multi_container_per_service' | 'sidecar_pattern';
  containerImages: ServiceContainerImage[];
  containerConfiguration: ServiceContainerConfiguration;
  containerDependencies: ServiceContainerDependency[];
}

export interface ServiceContainerImage {
  imageId: string;
  imageName: string;
  imageVersion: string;
  baseImage: string;
  imageSize: number; // MB
  imageLayers: number;
  securityScan: ContainerImageSecurityScan;
}

export interface ContainerImageSecurityScan {
  scanDate: Date;
  vulnerabilityCount: number;
  securityScore: number; // 0-100
  criticalVulnerabilities: number;
  recommendedActions: string[];
}

export interface ServiceContainerConfiguration {
  resourceLimits: ServiceResourceLimits;
  environmentVariables: ServiceEnvironmentVariable[];
  volumeMounts: ServiceVolumeMount[];
  networkConfiguration: ServiceNetworkConfiguration;
}

export interface ServiceResourceLimits {
  cpuLimit: string;
  memoryLimit: string;
  storageLimit: string;
  networkLimit?: string;
}

export interface ServiceEnvironmentVariable {
  variableName: string;
  variableValue: string;
  variableType: 'config' | 'secret' | 'computed';
  variableSource: string;
}

export interface ServiceVolumeMount {
  volumeName: string;
  mountPath: string;
  volumeType: 'persistent' | 'ephemeral' | 'config' | 'secret';
  accessMode: 'readwrite' | 'readonly';
}

export interface ServiceNetworkConfiguration {
  networkMode: 'bridge' | 'host' | 'custom';
  exposedPorts: ServiceExposedPort[];
  networkPolicies: string[];
  serviceMesh: boolean;
}

export interface ServiceExposedPort {
  portNumber: number;
  portProtocol: 'tcp' | 'udp';
  portType: 'internal' | 'external' | 'load_balancer';
  portDescription: string;
}

export interface ServiceContainerDependency {
  dependencyName: string;
  dependencyType: 'service' | 'database' | 'cache' | 'message_queue';
  dependencyVersion: string;
  dependencyRequired: boolean;
  dependencyConfiguration: any;
}

export interface ContainerImageOptimization {
  optimizationStrategy: 'multi_stage_builds' | 'alpine_base' | 'distroless' | 'scratch_based' | 'indonesian_optimized';
  imageSizeReduction: number; // percentage
  buildTimeOptimization: number; // percentage
  securityHardening: ContainerSecurityHardening;
  performanceOptimization: ContainerPerformanceOptimization;
}

export interface ContainerSecurityHardening {
  userConfiguration: 'root' | 'non_root' | 'restricted';
  fileSystemPermissions: 'default' | 'restricted' | 'read_only';
  capabilityDropping: string[];
  seccompProfile: boolean;
  apparmorProfile: boolean;
}

export interface ContainerPerformanceOptimization {
  startupOptimization: ContainerStartupOptimization;
  runtimeOptimization: ContainerRuntimeOptimization;
  resourceOptimization: ContainerResourceOptimizationConfig;
}

export interface ContainerStartupOptimization {
  lazyLoading: boolean;
  preWarmCache: boolean;
  parallelInitialization: boolean;
  startupTimeTarget: number; // seconds
}

export interface ContainerRuntimeOptimization {
  jvmTuning?: JvmTuningConfiguration;
  garbageCollection?: GarbageCollectionConfiguration;
  connectionPooling?: ConnectionPoolingConfiguration;
  caching?: CachingConfiguration;
}

export interface JvmTuningConfiguration {
  heapSize: string;
  metaspaceSize: string;
  gcAlgorithm: string;
  jvmFlags: string[];
}

export interface GarbageCollectionConfiguration {
  gcStrategy: string;
  gcTuning: string[];
  gcMonitoring: boolean;
}

export interface ConnectionPoolingConfiguration {
  maxPoolSize: number;
  minPoolSize: number;
  connectionTimeout: number; // seconds
  idleTimeout: number; // seconds
}

export interface CachingConfiguration {
  cacheStrategy: 'local' | 'distributed' | 'hybrid';
  cacheSize: string;
  cacheTtl: number; // seconds
  cacheEvictionPolicy: string;
}

export interface ContainerResourceOptimizationConfig {
  cpuOptimization: CpuOptimizationConfig;
  memoryOptimization: MemoryOptimizationConfig;
  storageOptimization: StorageOptimizationConfig;
  networkOptimization: NetworkOptimizationConfig;
}

export interface CpuOptimizationConfig {
  cpuShares: number;
  cpuQuota: number;
  cpuPeriod: number;
  cpuAffinity: string[];
}

export interface MemoryOptimizationConfig {
  memoryReservation: string;
  memorySwappiness: number;
  oomKillDisable: boolean;
  memoryPressureStrategy: string;
}

export interface StorageOptimizationConfig {
  storageDriver: string;
  storageOptions: string[];
  volumeOptimization: boolean;
  compressionEnabled: boolean;
}

export interface NetworkOptimizationConfig {
  networkDriver: string;
  networkOptions: string[];
  bandwidthLimiting: boolean;
  networkOptimizationLevel: 'basic' | 'advanced' | 'enterprise';
}

export interface ServiceDiscoveryContainerization {
  discoveryPlatform: 'consul' | 'eureka' | 'etcd' | 'kubernetes_dns' | 'istio';
  discoveryConfiguration: ServiceDiscoveryConfiguration;
  serviceRegistration: ServiceRegistrationConfig;
  healthChecking: ServiceHealthCheckingConfig;
}

export interface ServiceDiscoveryConfiguration {
  discoveryStrategy: 'client_side' | 'server_side' | 'service_mesh';
  discoveryProtocol: 'http' | 'grpc' | 'tcp';
  discoverySecurity: ServiceDiscoverySecurity;
  discoveryResilience: ServiceDiscoveryResilience;
}

export interface ServiceDiscoverySecurity {
  authenticationEnabled: boolean;
  authorizationEnabled: boolean;
  encryptionEnabled: boolean;
  certificateManagement: 'manual' | 'automatic' | 'cert_manager';
}

export interface ServiceDiscoveryResilience {
  retryPolicy: RetryPolicyConfig;
  circuitBreaker: CircuitBreakerConfig;
  timeout: TimeoutConfig;
  bulkhead: BulkheadConfig;
}

export interface RetryPolicyConfig {
  maxRetries: number;
  retryDelay: number; // milliseconds
  backoffStrategy: 'linear' | 'exponential' | 'fixed';
  retryConditions: string[];
}

export interface CircuitBreakerConfig {
  failureThreshold: number;
  recoveryTimeout: number; // seconds
  monitoringPeriod: number; // seconds
  halfOpenRetries: number;
}

export interface TimeoutConfig {
  connectionTimeout: number; // milliseconds
  requestTimeout: number; // milliseconds
  socketTimeout: number; // milliseconds
}

export interface BulkheadConfig {
  threadPoolSize: number;
  queueCapacity: number;
  isolationStrategy: 'thread' | 'semaphore';
}

export interface ServiceRegistrationConfig {
  registrationMode: 'automatic' | 'manual' | 'hybrid';
  registrationMetadata: ServiceRegistrationMetadata[];
  deregistrationPolicy: 'immediate' | 'graceful' | 'delayed';
  registrationValidation: boolean;
}

export interface ServiceRegistrationMetadata {
  metadataKey: string;
  metadataValue: any;
  metadataVisibility: 'public' | 'private' | 'internal';
  metadataUpdatePolicy: 'immutable' | 'mutable' | 'versioned';
}

export interface ServiceHealthCheckingConfig {
  healthCheckStrategy: 'push' | 'pull' | 'hybrid';
  healthCheckEndpoints: string[];
  healthCheckFrequency: number; // seconds
  healthCheckTimeout: number; // seconds
  healthCheckRetries: number;
}

export interface ApiGatewayContainerization {
  gatewayPlatform: 'nginx' | 'envoy' | 'istio' | 'kong' | 'ambassador';
  gatewayConfiguration: ApiGatewayConfiguration;
  routingConfiguration: ApiRoutingConfiguration;
  securityConfiguration: ApiSecurityConfiguration;
  rateLimitingConfiguration: ApiRateLimitingConfiguration;
}

export interface ApiGatewayConfiguration {
  gatewayMode: 'standalone' | 'sidecar' | 'distributed';
  gatewayDeployment: 'single_instance' | 'high_availability' | 'auto_scaling';
  gatewayProtocols: string[];
  gatewayPorts: number[];
}

export interface ApiRoutingConfiguration {
  routingStrategy: 'path_based' | 'host_based' | 'header_based' | 'weighted';
  routingRules: ApiRoutingRule[];
  loadBalancing: ApiLoadBalancingConfig;
  failover: ApiFailoverConfig;
}

export interface ApiRoutingRule {
  ruleId: string;
  ruleMatcher: ApiRuleMatcher;
  ruleAction: ApiRuleAction;
  ruleMetadata: any;
}

export interface ApiRuleMatcher {
  matchType: 'exact' | 'prefix' | 'regex' | 'header';
  matchValue: string;
  matchConditions: any[];
}

export interface ApiRuleAction {
  actionType: 'route' | 'redirect' | 'rewrite' | 'block';
  actionTarget: string;
  actionTransformation: any;
}

export interface ApiLoadBalancingConfig {
  algorithm: 'round_robin' | 'least_connections' | 'weighted' | 'hash';
  healthCheck: boolean;
  stickySessions: boolean;
  weightingStrategy: any;
}

export interface ApiFailoverConfig {
  failoverEnabled: boolean;
  failoverStrategy: 'immediate' | 'gradual' | 'circuit_breaker';
  backupTargets: string[];
  failoverConditions: string[];
}

export interface ApiSecurityConfiguration {
  authenticationMethods: string[];
  authorizationPolicies: string[];
  rateLimiting: boolean;
  ddosProtection: boolean;
  wafEnabled: boolean;
}

export interface ApiRateLimitingConfiguration {
  rateLimitingStrategy: 'fixed_window' | 'sliding_window' | 'token_bucket' | 'leaky_bucket';
  rateLimits: ApiRateLimit[];
  rateLimitingScope: 'global' | 'per_user' | 'per_ip' | 'per_api_key';
}

export interface ApiRateLimit {
  limitType: 'requests_per_second' | 'requests_per_minute' | 'requests_per_hour';
  limitValue: number;
  limitScope: string;
  limitExceededAction: 'block' | 'throttle' | 'queue';
}

export interface DataServiceContainerization {
  databaseContainerization: DatabaseContainerizationConfig;
  cacheContainerization: CacheContainerizationConfig;
  messageQueueContainerization: MessageQueueContainerizationConfig;
  dataBackupContainerization: DataBackupContainerizationConfig;
}

export interface DatabaseContainerizationConfig {
  databaseEngine: string;
  containerizedDatabases: ContainerizedDatabase[];
  dataVolumes: DatabaseVolume[];
  backupStrategy: DatabaseBackupStrategy;
  replicationConfig: DatabaseReplicationConfig;
}

export interface ContainerizedDatabase {
  databaseName: string;
  databaseVersion: string;
  containerImage: string;
  resourceRequirements: DatabaseResourceRequirements;
  securityConfiguration: DatabaseSecurityConfig;
}

export interface DatabaseResourceRequirements {
  cpuRequirement: string;
  memoryRequirement: string;
  storageRequirement: string;
  iopsRequirement: number;
}

export interface DatabaseSecurityConfig {
  encryptionAtRest: boolean;
  encryptionInTransit: boolean;
  accessControl: DatabaseAccessControl;
  auditLogging: boolean;
}

export interface DatabaseAccessControl {
  authenticationMethod: string;
  userRoles: DatabaseUserRole[];
  networkRestrictions: string[];
  sslRequired: boolean;
}

export interface DatabaseUserRole {
  roleName: string;
  permissions: string[];
  databaseAccess: string[];
  connectionLimits: number;
}

export interface DatabaseVolume {
  volumeName: string;
  volumeType: 'persistent' | 'ephemeral';
  volumeSize: string;
  storageClass: string;
  backupPolicy: string;
}

export interface DatabaseBackupStrategy {
  backupMethod: 'hot_backup' | 'cold_backup' | 'snapshot' | 'continuous';
  backupFrequency: string;
  backupRetention: string;
  backupDestination: string[];
}

export interface DatabaseReplicationConfig {
  replicationEnabled: boolean;
  replicationStrategy: 'master_slave' | 'master_master' | 'cluster';
  replicationLag: number; // seconds
  failoverAutomatic: boolean;
}

export interface CacheContainerizationConfig {
  cacheEngine: 'redis' | 'memcached' | 'hazelcast' | 'caffeine';
  cacheTopology: 'single_node' | 'cluster' | 'sentinel';
  cacheConfiguration: CacheConfiguration;
  cachePersistence: CachePersistenceConfig;
}

export interface CacheConfiguration {
  maxMemory: string;
  evictionPolicy: string;
  expirationPolicy: string;
  compressionEnabled: boolean;
  clusterConfiguration?: CacheClusterConfig;
}

export interface CacheClusterConfig {
  clusterNodes: number;
  shardingStrategy: string;
  replicationFactor: number;
  consistencyLevel: string;
}

export interface CachePersistenceConfig {
  persistenceEnabled: boolean;
  persistenceStrategy: 'rdb' | 'aof' | 'hybrid';
  persistenceInterval: string;
  persistenceLocation: string;
}

export interface MessageQueueContainerizationConfig {
  queueEngine: 'rabbitmq' | 'apache_kafka' | 'redis_streams' | 'amazon_sqs';
  queueTopology: 'single_broker' | 'cluster' | 'federated';
  queueConfiguration: MessageQueueConfiguration;
  messagePersistence: MessagePersistenceConfig;
}

export interface MessageQueueConfiguration {
  maxQueueSize: number;
  messageRetention: string;
  deliveryGuarantee: 'at_most_once' | 'at_least_once' | 'exactly_once';
  routingStrategy: string;
}

export interface MessagePersistenceConfig {
  persistenceEnabled: boolean;
  persistenceLocation: string;
  replicationFactor: number;
  compressionEnabled: boolean;
}

export interface DataBackupContainerizationConfig {
  backupOrchestration: 'kubernetes_jobs' | 'cron_jobs' | 'operator_based';
  backupSchedule: BackupScheduleConfig;
  backupStorage: BackupStorageConfig;
  backupEncryption: BackupEncryptionConfig;
}

export interface BackupScheduleConfig {
  scheduleType: 'cron' | 'interval' | 'event_based';
  scheduleExpression: string;
  backupWindow: string;
  maintenanceMode: boolean;
}

export interface BackupStorageConfig {
  storageType: 's3' | 'gcs' | 'azure_blob' | 'nfs' | 'local';
  storageLocation: string;
  storageClass: string;
  retentionPolicy: string;
}

export interface BackupEncryptionConfig {
  encryptionEnabled: boolean;
  encryptionAlgorithm: string;
  keyManagement: 'manual' | 'automatic' | 'external_kms';
  encryptionScope: 'client_side' | 'server_side' | 'both';
}

export interface MLServiceContainerization {
  mlFrameworkContainerization: MLFrameworkContainerizationConfig;
  modelServingContainerization: ModelServingContainerizationConfig;
  mlPipelineContainerization: MLPipelineContainerizationConfig;
  gpuResourceContainerization: GpuResourceContainerizationConfig;
}

export interface MLFrameworkContainerizationConfig {
  frameworks: MLFramework[];
  frameworkImages: MLFrameworkImage[];
  frameworkOptimization: MLFrameworkOptimization;
}

export interface MLFramework {
  frameworkName: string;
  frameworkVersion: string;
  frameworkType: 'training' | 'inference' | 'both';
  resourceRequirements: MLResourceRequirements;
}

export interface MLResourceRequirements {
  cpuRequirement: string;
  memoryRequirement: string;
  gpuRequirement?: string;
  storageRequirement: string;
}

export interface MLFrameworkImage {
  imageName: string;
  imageVersion: string;
  baseImage: string;
  optimizations: string[];
  securityScanning: boolean;
}

export interface MLFrameworkOptimization {
  performanceOptimizations: string[];
  resourceOptimizations: string[];
  securityHardening: string[];
  indonesianOptimizations: string[];
}

export interface ModelServingContainerization {
  servingPlatform: 'tensorflow_serving' | 'torchserve' | 'mlflow' | 'kubeflow' | 'seldon';
  servingConfiguration: ModelServingConfiguration;
  scalingConfiguration: ModelServingScalingConfig;
  monitoringConfiguration: ModelServingMonitoringConfig;
}

export interface ModelServingConfiguration {
  servingStrategy: 'single_model' | 'multi_model' | 'ensemble';
  servingProtocol: 'rest' | 'grpc' | 'both';
  batchProcessing: boolean;
  caching: ModelServingCacheConfig;
}

export interface ModelServingCacheConfig {
  cacheEnabled: boolean;
  cacheStrategy: 'model_cache' | 'prediction_cache' | 'both';
  cacheSize: string;
  cacheTtl: number; // seconds
}

export interface ModelServingScalingConfig {
  autoScaling: boolean;
  minReplicas: number;
  maxReplicas: number;
  scalingMetrics: string[];
  scalingThresholds: any;
}

export interface ModelServingMonitoringConfig {
  performanceMonitoring: boolean;
  driftDetection: boolean;
  latencyMonitoring: boolean;
  accuracyMonitoring: boolean;
}

export interface MLPipelineContainerization {
  pipelineOrchestration: 'kubeflow' | 'argo_workflows' | 'airflow' | 'tekton';
  pipelineComponents: MLPipelineComponent[];
  pipelineOptimization: MLPipelineOptimization;
}

export interface MLPipelineComponent {
  componentName: string;
  componentType: 'data_ingestion' | 'preprocessing' | 'training' | 'validation' | 'deployment';
  containerImage: string;
  resourceRequirements: MLResourceRequirements;
}

export interface MLPipelineOptimization {
  parallelization: boolean;
  resourceSharing: boolean;
  caching: boolean;
  pipelineTemplates: string[];
}

export interface GpuResourceContainerization {
  gpuSupport: boolean;
  gpuDriver: string;
  gpuScheduling: GpuSchedulingConfig;
  gpuMonitoring: GpuMonitoringConfig;
}

export interface GpuSchedulingConfig {
  schedulingStrategy: 'exclusive' | 'shared' | 'time_slicing';
  resourceAllocation: 'whole_gpu' | 'fractional_gpu' | 'multi_gpu';
  queueManagement: boolean;
}

export interface GpuMonitoringConfig {
  utilizationMonitoring: boolean;
  memoryMonitoring: boolean;
  temperatureMonitoring: boolean;
  powerMonitoring: boolean;
}

export interface IndonesianMicroservicesConfiguration {
  indonesianCompliance: IndonesianComplianceConfiguration;
  regionalOptimization: IndonesianRegionalOptimization;
  culturalAdaptation: IndonesianCulturalAdaptation;
  businessAlignment: IndonesianBusinessAlignment;
}

export interface IndonesianComplianceConfiguration {
  dataResidency: IndonesianDataResidencyConfig;
  regulatoryCompliance: IndonesianRegulatoryComplianceConfig;
  auditingRequirements: IndonesianAuditingConfig;
}

export interface IndonesianDataResidencyConfig {
  dataResidencyRequired: boolean;
  allowedRegions: string[];
  dataClassification: string[];
  crossBorderRestrictions: string[];
}

export interface IndonesianRegulatoryComplianceConfig {
  applicableRegulations: string[];
  complianceMonitoring: boolean;
  complianceReporting: boolean;
  complianceAutomation: boolean;
}

export interface IndonesianAuditingConfig {
  auditingEnabled: boolean;
  auditRetention: string;
  auditDestination: string[];
  auditCompliance: string[];
}

export interface IndonesianRegionalOptimization {
  regionDeployment: IndonesianRegionDeploymentConfig;
  networkOptimization: IndonesianNetworkOptimizationConfig;
  performanceOptimization: IndonesianPerformanceOptimizationConfig;
}

export interface IndonesianRegionDeploymentConfig {
  primaryRegion: string;
  secondaryRegions: string[];
  deploymentStrategy: 'active_active' | 'active_passive' | 'geo_distributed';
  failoverConfiguration: any;
}

export interface IndonesianNetworkOptimizationConfig {
  cdnConfiguration: string[];
  edgeCaching: boolean;
  networkAcceleration: boolean;
  localPeering: boolean;
}

export interface IndonesianPerformanceOptimizationConfig {
  timeZoneOptimization: boolean;
  businessHoursOptimization: boolean;
  culturalEventOptimization: boolean;
  localCachingStrategy: string;
}

export interface IndonesianCulturalAdaptation {
  languageSupport: IndonesianLanguageSupportConfig;
  culturalFactors: IndonesianCulturalFactorsConfig;
  businessPractices: IndonesianBusinessPracticesConfig;
}

export interface IndonesianLanguageSupportConfig {
  primaryLanguage: 'indonesian';
  secondaryLanguages: string[];
  localizationLevel: 'basic' | 'intermediate' | 'advanced' | 'native';
  culturalTranslation: boolean;
}

export interface IndonesianCulturalFactorsConfig {
  religiousConsiderations: string[];
  socialFactors: string[];
  traditionalPractices: string[];
  modernAdaptations: string[];
}

export interface IndonesianBusinessPracticesConfig {
  businessHours: IndonesianBusinessHoursConfig;
  paymentMethods: string[];
  businessRelationships: string[];
  decisionMaking: string;
}

export interface IndonesianBusinessHoursConfig {
  standardHours: string;
  ramadanHours: string;
  holidaySchedule: string[];
  regionalVariations: any;
}

export interface IndonesianBusinessAlignment {
  smeOptimization: IndonesianSmeOptimizationConfig;
  marketplaceIntegration: IndonesianMarketplaceIntegrationConfig;
  localSupplyChain: IndonesianLocalSupplyChainConfig;
}

export interface IndonesianSmeOptimizationConfig {
  smeResourceOptimization: boolean;
  smeCostOptimization: boolean;
  smeSimplification: boolean;
  smeSupport: string[];
}

export interface IndonesianMarketplaceIntegrationConfig {
  supportedMarketplaces: string[];
  integrationLevel: 'basic' | 'advanced' | 'enterprise';
  marketplaceOptimization: boolean;
  crossMarketplace: boolean;
}

export interface IndonesianLocalSupplyChainConfig {
  localSupplierIntegration: boolean;
  localLogistics: boolean;
  localPaymentGateways: boolean;
  localTaxCompliance: boolean;
}