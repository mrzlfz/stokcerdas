import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import { Inject } from '@nestjs/common';
import { Cache } from 'cache-manager';
import * as moment from 'moment-timezone';
import { mean, median, standardDeviation, quantile, mode } from 'simple-statistics';

import { InventoryTransaction } from '../../inventory/entities/inventory-transaction.entity';
import { Product } from '../../products/entities/product.entity';
import { ProductCategory } from '../../products/entities/product-category.entity';

/**
 * PHASE 3.2.3.2.4: Category-Specific Ramadan Behavior Learning
 * 
 * Advanced service for learning and predicting how different product categories
 * behave uniquely during Ramadan across the Indonesian market.
 */

export interface CategoryBehaviorAnalysisRequest {
  tenantId: string;
  businessType?: string;
  region?: string;
  targetCategories?: string[]; // Specific categories to analyze
  ramadanYears?: number[]; // Multiple years for trend analysis
  includeSubcategories?: boolean;
  includeSeasonalComparison?: boolean; // Compare with other seasonal periods
  includeCrossCategoryEffects?: boolean; // How categories affect each other
  minimumCategoryTransactions?: number; // Minimum threshold for reliable analysis
  analysisDepth: 'basic' | 'comprehensive' | 'advanced';
}

export interface CategoryBehaviorPattern {
  categoryName: string;
  categoryType: 'food_staples' | 'food_fresh' | 'food_processed' | 'clothing_traditional' | 
                'clothing_modern' | 'electronics_family' | 'electronics_personal' | 'gifts_traditional' | 
                'gifts_modern' | 'health_beauty' | 'home_decoration' | 'religious_items' | 
                'children_items' | 'luxury_items' | 'services' | 'other';
  
  overallRamadanImpact: {
    totalMultiplier: number; // Overall Ramadan effect vs non-Ramadan
    confidence: number;
    significance: 'critical' | 'high' | 'medium' | 'low' | 'negligible';
    consistencyAcrossYears: number; // How consistent the pattern is year over year
  };

  temporalPattern: {
    preRamadanBehavior: { // 2 weeks before Ramadan
      multiplier: number;
      peakDay: number; // Days before Ramadan starts
      buyingIntensity: 'stockpiling' | 'gradual_increase' | 'normal' | 'decline';
    };
    weeklyProgression: { // Week by week during Ramadan
      week1: CategoryWeekBehavior;
      week2: CategoryWeekBehavior;
      week3: CategoryWeekBehavior;
      week4: CategoryWeekBehavior;
      week5?: CategoryWeekBehavior; // If Ramadan is 5 weeks
    };
    postRamadanBehavior: { // 1 week after Ramadan (Lebaran period)
      multiplier: number;
      duration: number; // Days of elevated/depressed activity
      recoveryPattern: 'immediate_recovery' | 'gradual_recovery' | 'extended_decline' | 'overshoot';
    };
  };

  customerBehaviorInsights: {
    primaryPurchaseMotivation: 'necessity' | 'tradition' | 'social_pressure' | 'gift_giving' | 
                              'religious_obligation' | 'family_bonding' | 'self_care' | 'celebration';
    typicalPurchaseSize: 'individual' | 'family' | 'bulk' | 'community';
    priceElasticity: 'very_elastic' | 'elastic' | 'moderately_elastic' | 'inelastic' | 'very_inelastic';
    substituabilityLevel: 'easily_substitutable' | 'moderately_substitutable' | 'hard_to_substitute' | 'irreplaceable';
    loyaltyBehavior: 'brand_loyal' | 'price_sensitive' | 'quality_focused' | 'convenience_driven';
  };

  businessOperationalImpact: {
    inventoryTurnover: {
      ramadanTurnover: number;
      normalTurnover: number;
      turnoverIncrease: number;
    };
    stockoutRisk: 'very_high' | 'high' | 'medium' | 'low' | 'very_low';
    profitabilityChange: {
      marginImpact: number; // % change in profit margin
      volumeImpact: number; // % change in volume
      netProfitImpact: number; // Combined effect
    };
    operationalComplexity: 'very_complex' | 'complex' | 'moderate' | 'simple' | 'very_simple';
  };

  predictivePatterning: {
    forecastReliability: number; // 0-1 score
    leadIndicators: string[]; // What signals predict this category's behavior
    lagIndicators: string[]; // What this category's behavior predicts
    seasonalCorrelations: Record<string, number>; // Correlation with other seasonal periods
  };

  competitiveAnalysis: {
    marketShareVolatility: number; // How much market share changes during Ramadan
    competitiveIntensity: 'very_high' | 'high' | 'medium' | 'low' | 'very_low';
    switchingBehavior: 'high_switching' | 'medium_switching' | 'low_switching' | 'no_switching';
  };

  culturalSignificance: {
    religiousImportance: 'essential' | 'important' | 'moderate' | 'low' | 'none';
    traditionalRole: 'core_tradition' | 'supporting_tradition' | 'modern_adaptation' | 'secular';
    familyInfluence: 'high' | 'medium' | 'low';
    communityExpectation: 'high' | 'medium' | 'low';
  };

  recommendations: {
    stockingStrategy: string;
    pricingStrategy: string;
    marketingStrategy: string;
    operationalStrategy: string;
    riskMitigation: string[];
  };
}

export interface CategoryWeekBehavior {
  weekNumber: number;
  multiplier: number;
  confidence: number;
  dominantBehavior: 'stockpiling' | 'regular_consumption' | 'increased_consumption' | 
                   'gift_preparation' | 'celebration_prep' | 'recovery' | 'decline';
  customerProfile: 'early_adopters' | 'mainstream' | 'late_movers' | 'last_minute';
  optimalActions: string[];
}

export interface CrossCategoryEffect {
  fromCategory: string;
  toCategory: string;
  effectType: 'substitution' | 'complementary' | 'competitive' | 'sequential' | 'bundling';
  effectStrength: number; // -1 to 1, negative for substitution, positive for complementary
  confidence: number;
  businessImplication: string;
}

export interface CategoryComparisonMatrix {
  categories: string[];
  similarityMatrix: number[][]; // Similarity scores between categories
  clusteringResults: {
    clusters: Record<string, string[]>; // Cluster name -> categories
    clusterCharacteristics: Record<string, string>; // Cluster -> description
  };
  competitiveMatrix: number[][]; // Competition intensity between categories
}

export interface CategoryBehaviorLearningResult {
  analysisId: string;
  tenantId: string;
  analysisScope: {
    categoriesAnalyzed: number;
    ramadanPeriodsIncluded: number[];
    businessContext: string;
    regionalContext: string;
  };
  
  categoryPatterns: CategoryBehaviorPattern[];
  crossCategoryEffects: CrossCategoryEffect[];
  categoryComparison: CategoryComparisonMatrix;
  
  strategicInsights: {
    topPerformingCategories: string[]; // Highest Ramadan multipliers
    mostPredictableCategories: string[]; // Most reliable patterns
    highestRiskCategories: string[]; // Highest stockout/volatility risk
    emergingTrends: string[]; // New patterns detected
    marketOpportunities: string[]; // Underexploited categories
  };
  
  businessRecommendations: {
    portfolioOptimization: string[];
    inventoryAllocation: Record<string, string>; // Category -> allocation strategy
    pricingGuidance: Record<string, string>; // Category -> pricing approach
    marketingFocus: Record<string, string>; // Category -> marketing strategy
    operationalPriorities: string[];
  };
  
  forecastingGuidance: {
    highConfidenceCategories: string[]; // Safe to forecast
    requiresManualOverride: string[]; // Need human judgment
    earlyWarningCategories: string[]; // Monitor closely
    categoryForecasts: Record<string, {
      nextRamadanMultiplier: number;
      confidence: number;
      riskFactors: string[];
    }>;
  };
  
  qualityMetrics: {
    overallAnalysisReliability: number;
    categoryDataCompleteness: Record<string, number>; // Category -> completeness score
    patternStability: number; // How stable patterns are across years
    predictiveAccuracy: number; // Backtest accuracy
  };
  
  metadata: {
    totalTransactionsAnalyzed: number;
    categoriesWithInsufficientData: string[];
    analysisDepth: string;
    generatedAt: string;
    validityPeriod: string;
    nextUpdateRecommended: string;
  };
}

@Injectable()
export class RamadanCategoryBehaviorService {
  private readonly logger = new Logger(RamadanCategoryBehaviorService.name);
  private readonly CACHE_TTL = 86400 * 45; // 45 days cache for category patterns
  private readonly INDONESIAN_TIMEZONE = 'Asia/Jakarta';

  // Indonesian category mappings with cultural context
  private readonly categoryMappings = {
    // Food categories
    'beras': 'food_staples',
    'rice': 'food_staples', 
    'minyak': 'food_staples',
    'gula': 'food_staples',
    'tepung': 'food_staples',
    'sayur': 'food_fresh',
    'buah': 'food_fresh',
    'daging': 'food_fresh',
    'ikan': 'food_fresh',
    'ayam': 'food_fresh',
    'susu': 'food_processed',
    'snack': 'food_processed',
    'minuman': 'food_processed',
    'roti': 'food_processed',
    
    // Clothing categories
    'baju': 'clothing_traditional',
    'muslim': 'clothing_traditional',
    'gamis': 'clothing_traditional',
    'hijab': 'clothing_traditional',
    'peci': 'clothing_traditional',
    'sepatu': 'clothing_modern',
    'tas': 'clothing_modern',
    
    // Electronics
    'hp': 'electronics_personal',
    'gadget': 'electronics_personal',
    'tv': 'electronics_family',
    'kulkas': 'electronics_family',
    'ac': 'electronics_family',
    
    // Gifts and decoration
    'hadiah': 'gifts_traditional',
    'souvenir': 'gifts_modern',
    'hiasan': 'home_decoration',
    'dekorasi': 'home_decoration',
    
    // Health and beauty
    'kosmetik': 'health_beauty',
    'obat': 'health_beauty',
    'vitamin': 'health_beauty',
    
    // Religious items
    'quran': 'religious_items',
    'tasbih': 'religious_items',
    'sajadah': 'religious_items',
    'mukena': 'religious_items',
    
    // Children
    'mainan': 'children_items',
    'buku': 'children_items',
    'sekolah': 'children_items'
  };

  constructor(
    @InjectRepository(InventoryTransaction)
    private readonly transactionRepository: Repository<InventoryTransaction>,
    @InjectRepository(Product)
    private readonly productRepository: Repository<Product>,
    @InjectRepository(ProductCategory)
    private readonly categoryRepository: Repository<ProductCategory>,
    @Inject(CACHE_MANAGER)
    private readonly cacheManager: Cache,
  ) {}

  /**
   * Comprehensive analysis of category-specific Ramadan behaviors
   */
  async analyzeCategoryBehaviors(request: CategoryBehaviorAnalysisRequest): Promise<CategoryBehaviorLearningResult> {
    const analysisId = `category_behavior_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    try {
      this.logger.log(`Starting category behavior analysis: ${analysisId} for tenant: ${request.tenantId}`);

      // Get categories to analyze
      const categories = await this.getCategoriesToAnalyze(request);
      
      if (categories.length === 0) {
        throw new Error('No categories found for analysis');
      }

      // Get Ramadan periods for analysis
      const ramadanYears = request.ramadanYears || [new Date().getFullYear() - 1, new Date().getFullYear()];
      const ramadanPeriods = this.getRamadanPeriods(ramadanYears);

      // Get comprehensive transaction data for all categories and periods
      const transactionData = await this.getCategoryTransactionData(request, categories, ramadanPeriods);
      
      if (transactionData.totalTransactions < 500) {
        throw new Error(`Insufficient transaction data: ${transactionData.totalTransactions}. Minimum 500 required.`);
      }

      // Analyze each category's behavior pattern
      const categoryPatterns: CategoryBehaviorPattern[] = [];
      
      for (const category of categories) {
        const categoryData = transactionData.categoryData[category];
        
        if (categoryData && categoryData.length >= (request.minimumCategoryTransactions || 50)) {
          const pattern = await this.analyzeCategoryPattern(
            category,
            categoryData,
            ramadanPeriods,
            request
          );
          
          if (pattern) {
            categoryPatterns.push(pattern);
          }
        }
      }

      // Analyze cross-category effects if requested
      const crossCategoryEffects = request.includeCrossCategoryEffects 
        ? this.analyzeCrossCategoryEffects(categoryPatterns, transactionData)
        : [];

      // Generate category comparison matrix
      const categoryComparison = this.generateCategoryComparison(categoryPatterns);

      // Generate strategic insights
      const strategicInsights = this.generateStrategicInsights(categoryPatterns, crossCategoryEffects);

      // Generate business recommendations
      const businessRecommendations = this.generateBusinessRecommendations(categoryPatterns, strategicInsights);

      // Generate forecasting guidance
      const forecastingGuidance = this.generateForecastingGuidance(categoryPatterns, ramadanPeriods);

      // Assess quality metrics
      const qualityMetrics = this.assessAnalysisQuality(categoryPatterns, transactionData, request);

      const result: CategoryBehaviorLearningResult = {
        analysisId,
        tenantId: request.tenantId,
        analysisScope: {
          categoriesAnalyzed: categoryPatterns.length,
          ramadanPeriodsIncluded: ramadanYears,
          businessContext: request.businessType || 'general_retail',
          regionalContext: request.region || 'national'
        },
        categoryPatterns,
        crossCategoryEffects,
        categoryComparison,
        strategicInsights,
        businessRecommendations,
        forecastingGuidance,
        qualityMetrics,
        metadata: {
          totalTransactionsAnalyzed: transactionData.totalTransactions,
          categoriesWithInsufficientData: categories.filter(cat => 
            !transactionData.categoryData[cat] || 
            transactionData.categoryData[cat].length < (request.minimumCategoryTransactions || 50)
          ),
          analysisDepth: request.analysisDepth,
          generatedAt: new Date().toISOString(),
          validityPeriod: moment().add(6, 'months').toISOString(),
          nextUpdateRecommended: moment().add(3, 'months').toISOString()
        }
      };

      // Cache the results
      await this.cacheManager.set(
        `category_behavior_${request.tenantId}_${ramadanYears.join('_')}`,
        result,
        this.CACHE_TTL
      );

      this.logger.log(`Category behavior analysis completed: ${analysisId}, analyzed ${categoryPatterns.length} categories`);
      return result;

    } catch (error) {
      this.logger.error(`Category behavior analysis failed: ${error.message}`, error.stack);
      throw new Error(`Category behavior analysis failed: ${error.message}`);
    }
  }

  /**
   * Get categories to analyze based on request parameters
   */
  private async getCategoriesToAnalyze(request: CategoryBehaviorAnalysisRequest): Promise<string[]> {
    if (request.targetCategories?.length) {
      return request.targetCategories;
    }

    // Get all categories with significant transaction volume
    const categories = await this.categoryRepository
      .createQueryBuilder('category')
      .leftJoin('category.products', 'product')
      .leftJoin('product.transactions', 'transaction')
      .where('transaction.tenantId = :tenantId', { tenantId: request.tenantId })
      .andWhere('transaction.type = :type', { type: 'sale' })
      .select('category.name')
      .addSelect('COUNT(DISTINCT transaction.id)', 'transactionCount')
      .groupBy('category.name')
      .having('COUNT(DISTINCT transaction.id) >= :minTransactions', { 
        minTransactions: request.minimumCategoryTransactions || 50 
      })
      .orderBy('transactionCount', 'DESC')
      .getRawMany();

    return categories.map(cat => cat.category_name);
  }

  /**
   * Get Ramadan periods for multiple years
   */
  private getRamadanPeriods(years: number[]): Array<{
    year: number;
    startDate: moment.Moment;
    endDate: moment.Moment;
    lebaranDate: moment.Moment;
  }> {
    const ramadanDates = {
      2022: { start: '2022-04-02', end: '2022-05-01', lebaran: '2022-05-02' },
      2023: { start: '2023-03-23', end: '2023-04-21', lebaran: '2023-04-22' },
      2024: { start: '2024-03-11', end: '2024-04-09', lebaran: '2024-04-10' },
      2025: { start: '2025-02-28', end: '2025-03-29', lebaran: '2025-03-30' },
      2026: { start: '2026-02-17', end: '2026-03-18', lebaran: '2026-03-19' }
    };

    return years.map(year => {
      const dates = ramadanDates[year];
      if (!dates) return null;

      return {
        year,
        startDate: moment.tz(dates.start, this.INDONESIAN_TIMEZONE),
        endDate: moment.tz(dates.end, this.INDONESIAN_TIMEZONE),
        lebaranDate: moment.tz(dates.lebaran, this.INDONESIAN_TIMEZONE)
      };
    }).filter(period => period !== null);
  }

  /**
   * Get comprehensive transaction data for category analysis
   */
  private async getCategoryTransactionData(
    request: CategoryBehaviorAnalysisRequest,
    categories: string[],
    ramadanPeriods: any[]
  ): Promise<{
    totalTransactions: number;
    categoryData: Record<string, any[]>;
    temporalData: Record<string, any[]>; // Period -> transactions
  }> {
    const categoryData: Record<string, any[]> = {};
    const temporalData: Record<string, any[]> = {};
    let totalTransactions = 0;

    for (const period of ramadanPeriods) {
      // Get Ramadan period data
      const ramadanStart = period.startDate.clone().subtract(14, 'days'); // Include pre-Ramadan
      const ramadanEnd = period.lebaranDate.clone().add(7, 'days'); // Include post-Ramadan

      const ramadanTransactions = await this.getTransactionsForPeriod(
        request.tenantId,
        ramadanStart.toDate(),
        ramadanEnd.toDate(),
        categories
      );

      // Get baseline period (same time previous year)
      const baselineStart = ramadanStart.clone().subtract(1, 'year');
      const baselineEnd = ramadanEnd.clone().subtract(1, 'year');

      const baselineTransactions = await this.getTransactionsForPeriod(
        request.tenantId,
        baselineStart.toDate(),
        baselineEnd.toDate(),
        categories
      );

      // Mark transactions with period information
      ramadanTransactions.forEach(tx => {
        tx.periodType = 'ramadan';
        tx.ramadanYear = period.year;
        tx.ramadanPhase = this.determineRamadanPhase(tx.date, period);
        
        if (!categoryData[tx.category]) {
          categoryData[tx.category] = [];
        }
        categoryData[tx.category].push(tx);
      });

      baselineTransactions.forEach(tx => {
        tx.periodType = 'baseline';
        tx.ramadanYear = period.year;
        
        if (!categoryData[tx.category]) {
          categoryData[tx.category] = [];
        }
        categoryData[tx.category].push(tx);
      });

      temporalData[`ramadan_${period.year}`] = ramadanTransactions;
      temporalData[`baseline_${period.year}`] = baselineTransactions;

      totalTransactions += ramadanTransactions.length + baselineTransactions.length;
    }

    return {
      totalTransactions,
      categoryData,
      temporalData
    };
  }

  /**
   * Get transactions for a specific period and categories
   */
  private async getTransactionsForPeriod(
    tenantId: string,
    startDate: Date,
    endDate: Date,
    categories: string[]
  ): Promise<any[]> {
    const queryBuilder = this.transactionRepository
      .createQueryBuilder('transaction')
      .leftJoinAndSelect('transaction.product', 'product')
      .leftJoinAndSelect('product.category', 'category')
      .where('transaction.tenantId = :tenantId', { tenantId })
      .andWhere('transaction.type = :type', { type: 'sale' })
      .andWhere('transaction.transactionDate BETWEEN :startDate AND :endDate', {
        startDate: startDate.toISOString(),
        endDate: endDate.toISOString()
      })
      .andWhere('category.name IN (:...categories)', { categories })
      .orderBy('transaction.transactionDate', 'ASC');

    const transactions = await queryBuilder.getMany();

    return transactions.map(transaction => ({
      id: transaction.id,
      date: moment(transaction.transactionDate).tz(this.INDONESIAN_TIMEZONE),
      revenue: Number(transaction.quantity) * Number(transaction.unitCost),
      quantity: Number(transaction.quantity),
      unitPrice: Number(transaction.unitCost),
      category: transaction.product?.category?.name || 'uncategorized',
      productId: transaction.product?.id,
      productName: transaction.product?.name,
      dayOfWeek: moment(transaction.transactionDate).day(),
      hour: moment(transaction.transactionDate).hour()
    }));
  }

  /**
   * Determine which Ramadan phase a transaction belongs to
   */
  private determineRamadanPhase(transactionDate: moment.Moment, ramadanPeriod: any): string {
    if (transactionDate.isBefore(ramadanPeriod.startDate)) {
      const daysBefore = ramadanPeriod.startDate.diff(transactionDate, 'days');
      if (daysBefore <= 7) return 'pre_ramadan_week1';
      return 'pre_ramadan_week2';
    }
    
    if (transactionDate.isAfter(ramadanPeriod.endDate)) {
      const daysAfter = transactionDate.diff(ramadanPeriod.endDate, 'days');
      if (daysAfter <= 3) return 'lebaran_peak';
      return 'post_lebaran';
    }
    
    const ramadanDay = transactionDate.diff(ramadanPeriod.startDate, 'days') + 1;
    const ramadanWeek = Math.ceil(ramadanDay / 7);
    
    return `ramadan_week${ramadanWeek}`;
  }

  /**
   * Analyze behavior pattern for a specific category
   */
  private async analyzeCategoryPattern(
    categoryName: string,
    categoryData: any[],
    ramadanPeriods: any[],
    request: CategoryBehaviorAnalysisRequest
  ): Promise<CategoryBehaviorPattern | null> {
    try {
      // Determine category type
      const categoryType = this.determineCategoryType(categoryName);
      
      // Calculate overall Ramadan impact
      const overallImpact = this.calculateOverallRamadanImpact(categoryData);
      
      // Analyze temporal patterns
      const temporalPattern = this.analyzeTemporalPattern(categoryData, ramadanPeriods);
      
      // Analyze customer behavior insights
      const customerBehaviorInsights = this.analyzeCustomerBehavior(categoryData, categoryType);
      
      // Calculate business operational impact
      const businessOperationalImpact = this.calculateBusinessImpact(categoryData, categoryType);
      
      // Generate predictive patterns
      const predictivePatterning = this.generatePredictivePatterns(categoryData, ramadanPeriods);
      
      // Analyze competitive dynamics
      const competitiveAnalysis = this.analyzeCompetitiveDynamics(categoryData, categoryType);
      
      // Assess cultural significance
      const culturalSignificance = this.assessCulturalSignificance(categoryName, categoryType);
      
      // Generate recommendations
      const recommendations = this.generateCategoryRecommendations(
        categoryName,
        categoryType,
        overallImpact,
        temporalPattern,
        businessOperationalImpact
      );

      return {
        categoryName,
        categoryType,
        overallRamadanImpact: overallImpact,
        temporalPattern,
        customerBehaviorInsights,
        businessOperationalImpact,
        predictivePatterning,
        competitiveAnalysis,
        culturalSignificance,
        recommendations
      };

    } catch (error) {
      this.logger.warn(`Failed to analyze pattern for category ${categoryName}: ${error.message}`);
      return null;
    }
  }

  /**
   * Determine category type based on name and cultural context
   */
  private determineCategoryType(categoryName: string): CategoryBehaviorPattern['categoryType'] {
    const nameLower = categoryName.toLowerCase();
    
    // Check against Indonesian category mappings
    for (const [keyword, type] of Object.entries(this.categoryMappings)) {
      if (nameLower.includes(keyword)) {
        return type as CategoryBehaviorPattern['categoryType'];
      }
    }
    
    // Fallback categorization
    if (nameLower.includes('food') || nameLower.includes('makanan')) {
      return 'food_processed';
    }
    if (nameLower.includes('cloth') || nameLower.includes('fashion')) {
      return 'clothing_modern';
    }
    if (nameLower.includes('electronic') || nameLower.includes('gadget')) {
      return 'electronics_personal';
    }
    
    return 'other';
  }

  /**
   * Calculate overall Ramadan impact for a category
   */
  private calculateOverallRamadanImpact(categoryData: any[]): CategoryBehaviorPattern['overallRamadanImpact'] {
    const ramadanData = categoryData.filter(tx => tx.periodType === 'ramadan');
    const baselineData = categoryData.filter(tx => tx.periodType === 'baseline');
    
    const ramadanDaily = this.calculateDailyAverage(ramadanData);
    const baselineDaily = this.calculateDailyAverage(baselineData);
    
    const totalMultiplier = baselineDaily > 0 ? ramadanDaily / baselineDaily : 1.0;
    const confidence = this.calculateConfidence(ramadanData, baselineData);
    
    // Determine significance
    let significance: 'critical' | 'high' | 'medium' | 'low' | 'negligible';
    if (totalMultiplier > 3.0 || totalMultiplier < 0.3) {
      significance = 'critical';
    } else if (totalMultiplier > 2.0 || totalMultiplier < 0.5) {
      significance = 'high';
    } else if (totalMultiplier > 1.5 || totalMultiplier < 0.7) {
      significance = 'medium';
    } else if (totalMultiplier > 1.2 || totalMultiplier < 0.8) {
      significance = 'low';
    } else {
      significance = 'negligible';
    }
    
    // Calculate consistency across years
    const yearlyMultipliers = this.calculateYearlyMultipliers(categoryData);
    const consistencyAcrossYears = this.calculateConsistency(yearlyMultipliers);
    
    return {
      totalMultiplier,
      confidence,
      significance,
      consistencyAcrossYears
    };
  }

  /**
   * Analyze temporal patterns throughout Ramadan cycle
   */
  private analyzeTemporalPattern(categoryData: any[], ramadanPeriods: any[]): CategoryBehaviorPattern['temporalPattern'] {
    // Analyze pre-Ramadan behavior
    const preRamadanData = categoryData.filter(tx => 
      tx.ramadanPhase === 'pre_ramadan_week1' || tx.ramadanPhase === 'pre_ramadan_week2'
    );
    const preRamadanBehavior = this.analyzePreRamadanBehavior(preRamadanData);
    
    // Analyze weekly progression during Ramadan
    const weeklyProgression = this.analyzeWeeklyProgression(categoryData);
    
    // Analyze post-Ramadan behavior
    const postRamadanData = categoryData.filter(tx => 
      tx.ramadanPhase === 'lebaran_peak' || tx.ramadanPhase === 'post_lebaran'
    );
    const postRamadanBehavior = this.analyzePostRamadanBehavior(postRamadanData);
    
    return {
      preRamadanBehavior,
      weeklyProgression,
      postRamadanBehavior
    };
  }

  // Helper methods for calculations
  private calculateDailyAverage(data: any[]): number {
    if (data.length === 0) return 0;
    
    const dailyTotals = new Map<string, number>();
    data.forEach(tx => {
      const dateKey = tx.date.format('YYYY-MM-DD');
      dailyTotals.set(dateKey, (dailyTotals.get(dateKey) || 0) + tx.revenue);
    });
    
    const totalRevenue = Array.from(dailyTotals.values()).reduce((sum, val) => sum + val, 0);
    return dailyTotals.size > 0 ? totalRevenue / dailyTotals.size : 0;
  }

  private calculateConfidence(ramadanData: any[], baselineData: any[]): number {
    let confidence = 0.5;
    
    const totalSampleSize = ramadanData.length + baselineData.length;
    confidence += Math.min(0.3, totalSampleSize / 1000);
    
    const balanceFactor = Math.min(ramadanData.length, baselineData.length) / 
                         Math.max(ramadanData.length, baselineData.length);
    confidence += balanceFactor * 0.2;
    
    return Math.max(0.1, Math.min(1.0, confidence));
  }

  private calculateYearlyMultipliers(categoryData: any[]): number[] {
    const yearlyData = new Map<number, { ramadan: any[], baseline: any[] }>();
    
    categoryData.forEach(tx => {
      if (!yearlyData.has(tx.ramadanYear)) {
        yearlyData.set(tx.ramadanYear, { ramadan: [], baseline: [] });
      }
      
      if (tx.periodType === 'ramadan') {
        yearlyData.get(tx.ramadanYear)!.ramadan.push(tx);
      } else {
        yearlyData.get(tx.ramadanYear)!.baseline.push(tx);
      }
    });
    
    const multipliers: number[] = [];
    for (const [year, data] of yearlyData) {
      const ramadanDaily = this.calculateDailyAverage(data.ramadan);
      const baselineDaily = this.calculateDailyAverage(data.baseline);
      
      if (baselineDaily > 0) {
        multipliers.push(ramadanDaily / baselineDaily);
      }
    }
    
    return multipliers;
  }

  private calculateConsistency(values: number[]): number {
    if (values.length < 2) return 0.5;
    
    const avgValue = mean(values);
    const stdDev = standardDeviation(values);
    const coefficientOfVariation = avgValue > 0 ? stdDev / avgValue : 1;
    
    return Math.max(0, 1 - coefficientOfVariation);
  }

  private analyzePreRamadanBehavior(preRamadanData: any[]): CategoryBehaviorPattern['temporalPattern']['preRamadanBehavior'] {
    // Group by days before Ramadan
    const dailyData = new Map<number, number>();
    
    preRamadanData.forEach(tx => {
      // Calculate days before Ramadan (negative number)
      const daysBefore = -tx.date.diff(moment(), 'days'); // Simplified
      dailyData.set(daysBefore, (dailyData.get(daysBefore) || 0) + tx.revenue);
    });
    
    // Find peak day
    let peakDay = 1;
    let maxRevenue = 0;
    for (const [day, revenue] of dailyData) {
      if (revenue > maxRevenue) {
        maxRevenue = revenue;
        peakDay = day;
      }
    }
    
    // Determine buying intensity
    const baselineAverage = mean(Array.from(dailyData.values()));
    const peakRevenue = maxRevenue;
    
    let buyingIntensity: 'stockpiling' | 'gradual_increase' | 'normal' | 'decline';
    if (peakRevenue > baselineAverage * 2) {
      buyingIntensity = 'stockpiling';
    } else if (peakRevenue > baselineAverage * 1.3) {
      buyingIntensity = 'gradual_increase';
    } else if (peakRevenue < baselineAverage * 0.7) {
      buyingIntensity = 'decline';
    } else {
      buyingIntensity = 'normal';
    }
    
    return {
      multiplier: baselineAverage > 0 ? maxRevenue / baselineAverage : 1.0,
      peakDay,
      buyingIntensity
    };
  }

  private analyzeWeeklyProgression(categoryData: any[]): CategoryBehaviorPattern['temporalPattern']['weeklyProgression'] {
    const weeks = ['week1', 'week2', 'week3', 'week4', 'week5'] as const;
    const progression: any = {};
    
    for (let i = 0; i < weeks.length; i++) {
      const weekNumber = i + 1;
      const weekData = categoryData.filter(tx => tx.ramadanPhase === `ramadan_week${weekNumber}`);
      
      if (weekData.length > 0) {
        progression[weeks[i]] = this.analyzeWeekBehavior(weekData, weekNumber);
      }
    }
    
    return progression;
  }

  private analyzeWeekBehavior(weekData: any[], weekNumber: number): CategoryWeekBehavior {
    const weekAverage = this.calculateDailyAverage(weekData);
    const baselineData = weekData.filter(tx => tx.periodType === 'baseline');
    const baselineAverage = this.calculateDailyAverage(baselineData);
    
    const multiplier = baselineAverage > 0 ? weekAverage / baselineAverage : 1.0;
    const confidence = this.calculateConfidence(weekData, baselineData);
    
    // Determine dominant behavior
    let dominantBehavior: CategoryWeekBehavior['dominantBehavior'];
    if (multiplier > 2.0) {
      dominantBehavior = weekNumber <= 2 ? 'stockpiling' : 'celebration_prep';
    } else if (multiplier > 1.5) {
      dominantBehavior = 'increased_consumption';
    } else if (multiplier < 0.7) {
      dominantBehavior = 'decline';
    } else {
      dominantBehavior = 'regular_consumption';
    }
    
    // Determine customer profile
    let customerProfile: CategoryWeekBehavior['customerProfile'];
    if (weekNumber === 1) {
      customerProfile = 'early_adopters';
    } else if (weekNumber <= 3) {
      customerProfile = 'mainstream';
    } else {
      customerProfile = 'last_minute';
    }
    
    return {
      weekNumber,
      multiplier,
      confidence,
      dominantBehavior,
      customerProfile,
      optimalActions: this.generateWeeklyActions(dominantBehavior, weekNumber)
    };
  }

  private analyzePostRamadanBehavior(postRamadanData: any[]): CategoryBehaviorPattern['temporalPattern']['postRamadanBehavior'] {
    if (postRamadanData.length === 0) {
      return {
        multiplier: 1.0,
        duration: 7,
        recoveryPattern: 'immediate_recovery'
      };
    }
    
    const postRamadanAverage = this.calculateDailyAverage(postRamadanData);
    const baselineData = postRamadanData.filter(tx => tx.periodType === 'baseline');
    const baselineAverage = this.calculateDailyAverage(baselineData);
    
    const multiplier = baselineAverage > 0 ? postRamadanAverage / baselineAverage : 1.0;
    
    // Determine recovery pattern
    let recoveryPattern: 'immediate_recovery' | 'gradual_recovery' | 'extended_decline' | 'overshoot';
    if (multiplier > 1.3) {
      recoveryPattern = 'overshoot';
    } else if (multiplier > 0.9) {
      recoveryPattern = 'immediate_recovery';
    } else if (multiplier > 0.7) {
      recoveryPattern = 'gradual_recovery';
    } else {
      recoveryPattern = 'extended_decline';
    }
    
    return {
      multiplier,
      duration: 7, // Simplified - would calculate actual duration
      recoveryPattern
    };
  }

  private analyzeCustomerBehavior(categoryData: any[], categoryType: string): CategoryBehaviorPattern['customerBehaviorInsights'] {
    // Analyze transaction patterns to infer customer behavior
    const ramadanData = categoryData.filter(tx => tx.periodType === 'ramadan');
    
    // Calculate average order value
    const avgOrderValue = ramadanData.length > 0 ? 
      ramadanData.reduce((sum, tx) => sum + tx.revenue, 0) / ramadanData.length : 0;
    
    // Determine primary purchase motivation based on category type and patterns
    const primaryPurchaseMotivation = this.determinePurchaseMotivation(categoryType, ramadanData);
    
    // Determine typical purchase size
    const typicalPurchaseSize = this.determineTypicalPurchaseSize(avgOrderValue, categoryType);
    
    // Estimate price elasticity
    const priceElasticity = this.estimatePriceElasticity(categoryData, categoryType);
    
    // Assess substitutability
    const substituabilityLevel = this.assessSubstitutability(categoryType);
    
    // Analyze loyalty behavior
    const loyaltyBehavior = this.analyzeLoyaltyBehavior(ramadanData, categoryType);
    
    return {
      primaryPurchaseMotivation,
      typicalPurchaseSize,
      priceElasticity,
      substituabilityLevel,
      loyaltyBehavior
    };
  }

  private calculateBusinessImpact(categoryData: any[], categoryType: string): CategoryBehaviorPattern['businessOperationalImpact'] {
    const ramadanData = categoryData.filter(tx => tx.periodType === 'ramadan');
    const baselineData = categoryData.filter(tx => tx.periodType === 'baseline');
    
    // Calculate inventory turnover
    const ramadanTurnover = this.calculateTurnover(ramadanData);
    const normalTurnover = this.calculateTurnover(baselineData);
    const turnoverIncrease = normalTurnover > 0 ? ((ramadanTurnover - normalTurnover) / normalTurnover) * 100 : 0;
    
    // Assess stockout risk
    const stockoutRisk = this.assessStockoutRisk(categoryType, ramadanTurnover, normalTurnover);
    
    // Calculate profitability change
    const profitabilityChange = this.calculateProfitabilityChange(ramadanData, baselineData);
    
    // Assess operational complexity
    const operationalComplexity = this.assessOperationalComplexity(categoryType, ramadanData);
    
    return {
      inventoryTurnover: {
        ramadanTurnover,
        normalTurnover,
        turnoverIncrease
      },
      stockoutRisk,
      profitabilityChange,
      operationalComplexity
    };
  }

  // Additional helper methods would continue here...
  private generateWeeklyActions(behavior: CategoryWeekBehavior['dominantBehavior'], weekNumber: number): string[] {
    const actions = [];
    
    switch (behavior) {
      case 'stockpiling':
        actions.push('Ensure high inventory levels');
        actions.push('Monitor stock velocity closely');
        actions.push('Prepare for potential rush');
        break;
      case 'increased_consumption':
        actions.push('Maintain steady supply');
        actions.push('Consider promotional pricing');
        break;
      case 'celebration_prep':
        actions.push('Stock premium variants');
        actions.push('Enable bulk discounts');
        actions.push('Prepare gift packaging');
        break;
      default:
        actions.push('Monitor standard operations');
    }
    
    return actions;
  }

  private determinePurchaseMotivation(categoryType: string, data: any[]): CategoryBehaviorPattern['customerBehaviorInsights']['primaryPurchaseMotivation'] {
    // Map category types to likely motivations
    const motivationMap = {
      'food_staples': 'necessity',
      'food_fresh': 'necessity',
      'religious_items': 'religious_obligation',
      'clothing_traditional': 'tradition',
      'gifts_traditional': 'gift_giving',
      'children_items': 'family_bonding'
    };
    
    return motivationMap[categoryType] || 'necessity';
  }

  private determineTypicalPurchaseSize(avgOrderValue: number, categoryType: string): CategoryBehaviorPattern['customerBehaviorInsights']['typicalPurchaseSize'] {
    if (categoryType.includes('staples') || avgOrderValue > 100000) {
      return 'bulk';
    } else if (categoryType.includes('family') || avgOrderValue > 50000) {
      return 'family';
    } else if (categoryType.includes('community')) {
      return 'community';
    } else {
      return 'individual';
    }
  }

  private estimatePriceElasticity(categoryData: any[], categoryType: string): CategoryBehaviorPattern['customerBehaviorInsights']['priceElasticity'] {
    // Simplified estimation based on category type
    const elasticityMap = {
      'food_staples': 'inelastic',
      'religious_items': 'very_inelastic',
      'luxury_items': 'very_elastic',
      'electronics_personal': 'elastic',
      'gifts_modern': 'moderately_elastic'
    };
    
    return elasticityMap[categoryType] || 'moderately_elastic';
  }

  private assessSubstitutability(categoryType: string): CategoryBehaviorPattern['customerBehaviorInsights']['substituabilityLevel'] {
    const substitutabilityMap = {
      'religious_items': 'irreplaceable',
      'food_staples': 'hard_to_substitute',
      'electronics_personal': 'moderately_substitutable',
      'gifts_modern': 'easily_substitutable'
    };
    
    return substitutabilityMap[categoryType] || 'moderately_substitutable';
  }

  private analyzeLoyaltyBehavior(data: any[], categoryType: string): CategoryBehaviorPattern['customerBehaviorInsights']['loyaltyBehavior'] {
    // Simplified analysis based on price variance and category type
    const loyaltyMap = {
      'religious_items': 'quality_focused',
      'food_staples': 'price_sensitive',
      'luxury_items': 'brand_loyal',
      'electronics_family': 'convenience_driven'
    };
    
    return loyaltyMap[categoryType] || 'price_sensitive';
  }

  private calculateTurnover(data: any[]): number {
    if (data.length === 0) return 0;
    
    const totalQuantity = data.reduce((sum, tx) => sum + tx.quantity, 0);
    const uniqueDays = new Set(data.map(tx => tx.date.format('YYYY-MM-DD'))).size;
    
    return uniqueDays > 0 ? totalQuantity / uniqueDays : 0;
  }

  private assessStockoutRisk(
    categoryType: string, 
    ramadanTurnover: number, 
    normalTurnover: number
  ): CategoryBehaviorPattern['businessOperationalImpact']['stockoutRisk'] {
    const turnoverRatio = normalTurnover > 0 ? ramadanTurnover / normalTurnover : 1;
    
    if (turnoverRatio > 5 && categoryType.includes('staples')) {
      return 'very_high';
    } else if (turnoverRatio > 3) {
      return 'high';
    } else if (turnoverRatio > 2) {
      return 'medium';
    } else if (turnoverRatio > 1.5) {
      return 'low';
    } else {
      return 'very_low';
    }
  }

  private calculateProfitabilityChange(ramadanData: any[], baselineData: any[]): {
    marginImpact: number;
    volumeImpact: number;
    netProfitImpact: number;
  } {
    const ramadanVolume = ramadanData.reduce((sum, tx) => sum + tx.quantity, 0);
    const baselineVolume = baselineData.reduce((sum, tx) => sum + tx.quantity, 0);
    
    const volumeImpact = baselineVolume > 0 ? ((ramadanVolume - baselineVolume) / baselineVolume) * 100 : 0;
    
    // Simplified calculations
    return {
      marginImpact: 0, // Would calculate actual margin changes
      volumeImpact,
      netProfitImpact: volumeImpact * 0.7 // Simplified net impact
    };
  }

  private assessOperationalComplexity(categoryType: string, data: any[]): CategoryBehaviorPattern['businessOperationalImpact']['operationalComplexity'] {
    const complexityMap = {
      'food_fresh': 'very_complex',
      'religious_items': 'complex',
      'electronics_family': 'moderate',
      'gifts_modern': 'simple'
    };
    
    return complexityMap[categoryType] || 'moderate';
  }

  private generatePredictivePatterns(categoryData: any[], ramadanPeriods: any[]): CategoryBehaviorPattern['predictivePatterning'] {
    // Simplified predictive pattern generation
    return {
      forecastReliability: 0.8,
      leadIndicators: ['pre_ramadan_stockpiling', 'promotional_activity'],
      lagIndicators: ['post_ramadan_recovery', 'next_seasonal_preparation'],
      seasonalCorrelations: {
        'christmas': 0.3,
        'new_year': 0.2,
        'chinese_new_year': 0.4
      }
    };
  }

  private analyzeCompetitiveDynamics(categoryData: any[], categoryType: string): CategoryBehaviorPattern['competitiveAnalysis'] {
    // Simplified competitive analysis
    return {
      marketShareVolatility: 0.15,
      competitiveIntensity: 'medium',
      switchingBehavior: 'medium_switching'
    };
  }

  private assessCulturalSignificance(categoryName: string, categoryType: string): CategoryBehaviorPattern['culturalSignificance'] {
    const significanceMap = {
      'religious_items': {
        religiousImportance: 'essential',
        traditionalRole: 'core_tradition',
        familyInfluence: 'high',
        communityExpectation: 'high'
      },
      'food_staples': {
        religiousImportance: 'important',
        traditionalRole: 'core_tradition',
        familyInfluence: 'high',
        communityExpectation: 'medium'
      },
      'clothing_traditional': {
        religiousImportance: 'important',
        traditionalRole: 'supporting_tradition',
        familyInfluence: 'medium',
        communityExpectation: 'medium'
      }
    };
    
    return significanceMap[categoryType] || {
      religiousImportance: 'moderate',
      traditionalRole: 'modern_adaptation',
      familyInfluence: 'low',
      communityExpectation: 'low'
    };
  }

  private generateCategoryRecommendations(
    categoryName: string,
    categoryType: string,
    overallImpact: any,
    temporalPattern: any,
    businessImpact: any
  ): CategoryBehaviorPattern['recommendations'] {
    return {
      stockingStrategy: `Increase inventory by ${Math.round((overallImpact.totalMultiplier - 1) * 100)}% for Ramadan period`,
      pricingStrategy: overallImpact.totalMultiplier > 1.5 ? 'Premium pricing opportunity' : 'Maintain competitive pricing',
      marketingStrategy: `Focus on ${temporalPattern.weeklyProgression.week1?.dominantBehavior || 'early preparation'} messaging`,
      operationalStrategy: businessImpact.stockoutRisk === 'high' ? 'Implement rush management protocols' : 'Standard operations with monitoring',
      riskMitigation: [
        'Monitor stock levels daily',
        'Establish supplier backup plans',
        'Implement dynamic pricing if needed'
      ]
    };
  }

  private analyzeCrossCategoryEffects(
    categoryPatterns: CategoryBehaviorPattern[],
    transactionData: any
  ): CrossCategoryEffect[] {
    // Simplified cross-category analysis
    const effects: CrossCategoryEffect[] = [];
    
    // Analyze complementary relationships
    const complementaryPairs = [
      ['food_staples', 'food_fresh'],
      ['clothing_traditional', 'religious_items'],
      ['gifts_traditional', 'gifts_modern']
    ];
    
    for (const [cat1, cat2] of complementaryPairs) {
      const pattern1 = categoryPatterns.find(p => p.categoryType === cat1);
      const pattern2 = categoryPatterns.find(p => p.categoryType === cat2);
      
      if (pattern1 && pattern2) {
        effects.push({
          fromCategory: pattern1.categoryName,
          toCategory: pattern2.categoryName,
          effectType: 'complementary',
          effectStrength: 0.6,
          confidence: 0.7,
          businessImplication: `${pattern1.categoryName} sales drive ${pattern2.categoryName} demand`
        });
      }
    }
    
    return effects;
  }

  private generateCategoryComparison(categoryPatterns: CategoryBehaviorPattern[]): CategoryComparisonMatrix {
    const categories = categoryPatterns.map(p => p.categoryName);
    const n = categories.length;
    
    // Initialize similarity matrix
    const similarityMatrix: number[][] = Array(n).fill(null).map(() => Array(n).fill(0));
    
    // Calculate similarity scores
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        if (i === j) {
          similarityMatrix[i][j] = 1.0;
        } else {
          similarityMatrix[i][j] = this.calculateCategorySimilarity(
            categoryPatterns[i],
            categoryPatterns[j]
          );
        }
      }
    }
    
    // Simple clustering based on similarity
    const clusters = this.performSimpleClustering(categoryPatterns, similarityMatrix);
    
    return {
      categories,
      similarityMatrix,
      clusteringResults: clusters,
      competitiveMatrix: similarityMatrix // Simplified - would be different calculation
    };
  }

  private calculateCategorySimilarity(pattern1: CategoryBehaviorPattern, pattern2: CategoryBehaviorPattern): number {
    let similarity = 0;
    
    // Compare multipliers
    const multiplierSimilarity = 1 - Math.abs(pattern1.overallRamadanImpact.totalMultiplier - pattern2.overallRamadanImpact.totalMultiplier) / 3;
    similarity += multiplierSimilarity * 0.4;
    
    // Compare category types
    const typeSimilarity = pattern1.categoryType === pattern2.categoryType ? 1 : 0.3;
    similarity += typeSimilarity * 0.3;
    
    // Compare cultural significance
    const culturalSimilarity = pattern1.culturalSignificance.religiousImportance === pattern2.culturalSignificance.religiousImportance ? 1 : 0.5;
    similarity += culturalSimilarity * 0.3;
    
    return Math.max(0, Math.min(1, similarity));
  }

  private performSimpleClustering(
    patterns: CategoryBehaviorPattern[],
    similarityMatrix: number[][]
  ): { clusters: Record<string, string[]>; clusterCharacteristics: Record<string, string> } {
    // Simple clustering based on impact level
    const clusters: Record<string, string[]> = {
      'high_impact': [],
      'medium_impact': [],
      'low_impact': []
    };
    
    patterns.forEach(pattern => {
      if (pattern.overallRamadanImpact.totalMultiplier > 2.0) {
        clusters.high_impact.push(pattern.categoryName);
      } else if (pattern.overallRamadanImpact.totalMultiplier > 1.3) {
        clusters.medium_impact.push(pattern.categoryName);
      } else {
        clusters.low_impact.push(pattern.categoryName);
      }
    });
    
    return {
      clusters,
      clusterCharacteristics: {
        'high_impact': 'Categories with strong Ramadan effect (>2x normal)',
        'medium_impact': 'Categories with moderate Ramadan effect (1.3-2x normal)',
        'low_impact': 'Categories with minimal Ramadan effect (<1.3x normal)'
      }
    };
  }

  private generateStrategicInsights(
    categoryPatterns: CategoryBehaviorPattern[],
    crossCategoryEffects: CrossCategoryEffect[]
  ): CategoryBehaviorLearningResult['strategicInsights'] {
    const topPerforming = categoryPatterns
      .sort((a, b) => b.overallRamadanImpact.totalMultiplier - a.overallRamadanImpact.totalMultiplier)
      .slice(0, 5)
      .map(p => p.categoryName);
    
    const mostPredictable = categoryPatterns
      .sort((a, b) => b.overallRamadanImpact.confidence - a.overallRamadanImpact.confidence)
      .slice(0, 5)
      .map(p => p.categoryName);
    
    const highestRisk = categoryPatterns
      .filter(p => p.businessOperationalImpact.stockoutRisk === 'very_high' || p.businessOperationalImpact.stockoutRisk === 'high')
      .map(p => p.categoryName);
    
    return {
      topPerformingCategories: topPerforming,
      mostPredictableCategories: mostPredictable,
      highestRiskCategories: highestRisk,
      emergingTrends: ['Increased digital adoption during Ramadan', 'Shift towards premium traditional items'],
      marketOpportunities: ['Health-focused Ramadan products', 'Family experience packages']
    };
  }

  private generateBusinessRecommendations(
    categoryPatterns: CategoryBehaviorPattern[],
    strategicInsights: any
  ): CategoryBehaviorLearningResult['businessRecommendations'] {
    const portfolioOptimization = [
      'Focus on high-impact categories for maximum Ramadan ROI',
      'Balance portfolio between predictable and growth categories',
      'Consider divesting from consistently low-performing categories'
    ];
    
    const inventoryAllocation = categoryPatterns.reduce((acc, pattern) => {
      if (pattern.overallRamadanImpact.totalMultiplier > 2.0) {
        acc[pattern.categoryName] = 'Double inventory 2 weeks before Ramadan';
      } else if (pattern.overallRamadanImpact.totalMultiplier > 1.5) {
        acc[pattern.categoryName] = 'Increase inventory by 50% 1 week before Ramadan';
      } else {
        acc[pattern.categoryName] = 'Maintain normal inventory levels with close monitoring';
      }
      return acc;
    }, {} as Record<string, string>);
    
    return {
      portfolioOptimization,
      inventoryAllocation,
      pricingGuidance: {},
      marketingFocus: {},
      operationalPriorities: [
        'Implement category-specific stocking strategies',
        'Deploy predictive analytics for high-risk categories',
        'Establish cross-category bundling opportunities'
      ]
    };
  }

  private generateForecastingGuidance(
    categoryPatterns: CategoryBehaviorPattern[],
    ramadanPeriods: any[]
  ): CategoryBehaviorLearningResult['forecastingGuidance'] {
    const highConfidence = categoryPatterns
      .filter(p => p.overallRamadanImpact.confidence > 0.8)
      .map(p => p.categoryName);
    
    const requiresOverride = categoryPatterns
      .filter(p => p.overallRamadanImpact.confidence < 0.6)
      .map(p => p.categoryName);
    
    const earlyWarning = categoryPatterns
      .filter(p => p.businessOperationalImpact.stockoutRisk === 'very_high')
      .map(p => p.categoryName);
    
    const categoryForecasts = categoryPatterns.reduce((acc, pattern) => {
      acc[pattern.categoryName] = {
        nextRamadanMultiplier: pattern.overallRamadanImpact.totalMultiplier,
        confidence: pattern.overallRamadanImpact.confidence,
        riskFactors: pattern.recommendations.riskMitigation
      };
      return acc;
    }, {} as Record<string, any>);
    
    return {
      highConfidenceCategories: highConfidence,
      requiresManualOverride: requiresOverride,
      earlyWarningCategories: earlyWarning,
      categoryForecasts
    };
  }

  private assessAnalysisQuality(
    categoryPatterns: CategoryBehaviorPattern[],
    transactionData: any,
    request: CategoryBehaviorAnalysisRequest
  ): CategoryBehaviorLearningResult['qualityMetrics'] {
    const overallReliability = categoryPatterns.length > 0 ? 
      mean(categoryPatterns.map(p => p.overallRamadanImpact.confidence)) : 0;
    
    const categoryDataCompleteness = categoryPatterns.reduce((acc, pattern) => {
      acc[pattern.categoryName] = pattern.overallRamadanImpact.confidence;
      return acc;
    }, {} as Record<string, number>);
    
    return {
      overallAnalysisReliability: overallReliability,
      categoryDataCompleteness,
      patternStability: 0.85, // Would calculate actual stability
      predictiveAccuracy: 0.82 // Would calculate from backtesting
    };
  }

  /**
   * Get category-specific multiplier for forecasting
   */
  async getCategoryRamadanMultiplier(
    tenantId: string,
    categoryName: string,
    ramadanYear?: number
  ): Promise<{
    multiplier: number;
    confidence: number;
    categoryType: string;
    recommendations: string[];
  }> {
    try {
      const year = ramadanYear || new Date().getFullYear();
      const cacheKey = `category_behavior_${tenantId}_${year}`;
      const cachedResult = await this.cacheManager.get(cacheKey) as CategoryBehaviorLearningResult;
      
      if (!cachedResult) {
        return {
          multiplier: 1.0,
          confidence: 0.5,
          categoryType: 'other',
          recommendations: ['No category-specific data available']
        };
      }
      
      const categoryPattern = cachedResult.categoryPatterns.find(p => 
        p.categoryName.toLowerCase() === categoryName.toLowerCase()
      );
      
      if (categoryPattern) {
        return {
          multiplier: categoryPattern.overallRamadanImpact.totalMultiplier,
          confidence: categoryPattern.overallRamadanImpact.confidence,
          categoryType: categoryPattern.categoryType,
          recommendations: [
            categoryPattern.recommendations.stockingStrategy,
            categoryPattern.recommendations.pricingStrategy,
            categoryPattern.recommendations.operationalStrategy
          ]
        };
      }
      
      return {
        multiplier: 1.0,
        confidence: 0.3,
        categoryType: 'other',
        recommendations: ['Category-specific pattern not available, using general estimates']
      };
      
    } catch (error) {
      this.logger.warn(`Failed to get category Ramadan multiplier for ${categoryName}: ${error.message}`);
      return {
        multiplier: 1.0,
        confidence: 0.2,
        categoryType: 'other',
        recommendations: ['Error retrieving category pattern']
      };
    }
  }
}