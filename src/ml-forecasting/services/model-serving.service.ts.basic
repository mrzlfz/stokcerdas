import { Injectable, Logger } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, Between } from 'typeorm';
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import { Inject } from '@nestjs/common';
import { Cache } from 'cache-manager';
import { ConfigService } from '@nestjs/config';
import * as fs from 'fs';
import * as moment from 'moment-timezone';

import { MLModel, ModelType, ModelStatus } from '../entities/ml-model.entity';
import {
  Prediction,
  PredictionType,
  PredictionStatus,
} from '../entities/prediction.entity';
import { Product } from '../../products/entities/product.entity';
import { InventoryItem } from '../../inventory/entities/inventory-item.entity';
import { DataPipelineService } from './data-pipeline.service';
import { RealMLService } from './real-ml.service';

export interface PredictionRequest {
  modelId?: string;
  productId?: string;
  categoryId?: string;
  locationId?: string;
  predictionType: PredictionType;
  targetDate?: Date;
  forecastDays?: number;
  includeConfidenceInterval?: boolean;
  features?: Record<string, any>;
}

export interface PredictionResult {
  success: boolean;
  predictionId?: string;
  predictedValue?: number;
  confidence?: number;
  lowerBound?: number;
  upperBound?: number;
  timeSeries?: Array<{
    date: string;
    value: number;
    lowerBound?: number;
    upperBound?: number;
  }>;
  actionableInsights?: {
    recommendations?: string[];
    alerts?: Array<{
      type: string;
      severity: 'low' | 'medium' | 'high' | 'critical';
      message: string;
    }>;
  };
  error?: string;
}

export interface BatchPredictionRequest {
  modelId?: string;
  productIds?: string[];
  predictionType: PredictionType;
  targetDate?: Date;
  forecastDays?: number;
}

@Injectable()
export class ModelServingService {
  private readonly logger = new Logger(ModelServingService.name);
  private readonly modelCache = new Map<string, any>();

  constructor(
    @InjectRepository(MLModel)
    private mlModelRepo: Repository<MLModel>,

    @InjectRepository(Prediction)
    private predictionRepo: Repository<Prediction>,

    @InjectRepository(Product)
    private productRepo: Repository<Product>,

    @InjectRepository(InventoryItem)
    private inventoryItemRepo: Repository<InventoryItem>,

    @Inject(CACHE_MANAGER)
    private cacheManager: Cache,

    private dataPipelineService: DataPipelineService,
    private configService: ConfigService,
    private realMLService: RealMLService,
  ) {}

  /**
   * Generate prediction for a single product/entity
   */
  async predict(
    tenantId: string,
    request: PredictionRequest,
  ): Promise<PredictionResult> {
    this.logger.debug(`Generating prediction for tenant ${tenantId}`);

    try {
      // Find appropriate model
      const model = await this.findBestModel(tenantId, request);

      if (!model) {
        return {
          success: false,
          error: 'Model prediksi yang sesuai tidak ditemukan',
          actionableInsights: {
            recommendations: [
              'Periksa kembali data input yang diberikan',
              'Pastikan produk terdaftar dengan benar dalam sistem',
              'Hubungi administrator jika masalah berlanjut',
            ],
            alerts: [
              {
                type: 'no_model_found',
                severity: 'medium',
                message: 'Model prediksi tidak tersedia untuk produk ini. Sistem akan menggunakan metode estimasi sederhana.',
              },
            ],
          },
        };
      }

      // Check cache for recent predictions
      const cacheKey = this.buildCacheKey(tenantId, request, model.id);
      const cached = await this.cacheManager.get<PredictionResult>(cacheKey);

      if (cached) {
        this.logger.debug('Returning cached prediction');
        return cached;
      }

      // Load model if not in memory
      const loadedModel = await this.loadModel(model);

      // Prepare features
      const features = await this.prepareFeatures(tenantId, request);

      // Generate prediction
      const predictionValue = await this.generatePrediction(
        loadedModel,
        features,
        request.forecastDays || 30,
      );

      // Calculate confidence and bounds
      const confidence = this.calculateConfidence(model, features);
      const bounds = this.calculateConfidenceBounds(
        predictionValue,
        confidence,
      );

      // Create prediction record
      const prediction = new Prediction();
      prediction.tenantId = tenantId;
      prediction.modelId = model.id;
      prediction.productId = request.productId;
      prediction.categoryId = request.categoryId;
      prediction.locationId = request.locationId;
      prediction.predictionType = request.predictionType;
      prediction.targetDate = request.targetDate || new Date();
      prediction.predictedValue = predictionValue;
      prediction.confidence = confidence;
      prediction.lowerBound = bounds.lower;
      prediction.upperBound = bounds.upper;
      prediction.forecastHorizonDays = request.forecastDays || 30;
      prediction.inputFeatures = features;
      prediction.updateConfidenceLevel();

      // Generate time series if requested
      if (request.forecastDays && request.forecastDays > 1) {
        prediction.predictionData = {
          timeSeries: await this.generateTimeSeriesForecast(
            loadedModel,
            features,
            request.forecastDays,
          ),
        };
      }

      // Generate actionable insights
      const insights = await this.generateActionableInsights(
        tenantId,
        prediction,
        model,
      );

      prediction.addActionableInsight(insights);

      // Calculate business impact
      const businessImpact = await this.calculateBusinessImpact(
        tenantId,
        prediction,
      );

      prediction.setBusinessImpact(businessImpact);

      prediction.complete();
      const savedPrediction = await this.predictionRepo.save(prediction);

      // Update model usage
      model.recordPrediction();
      await this.mlModelRepo.save(model);

      const result: PredictionResult = {
        success: true,
        predictionId: savedPrediction.id,
        predictedValue: predictionValue,
        confidence,
        lowerBound: bounds.lower,
        upperBound: bounds.upper,
        timeSeries: prediction.predictionData?.timeSeries,
        actionableInsights: insights,
      };

      // Cache result for 1 hour
      await this.cacheManager.set(cacheKey, result, 3600);

      return result;
    } catch (error) {
      this.logger.error(
        `Prediction failed for tenant ${tenantId}: ${error.message}`,
        error.stack,
      );
      
      // Provide graceful fallback with Indonesian localization
      return {
        success: false,
        error: this.getLocalizedErrorMessage(error),
        actionableInsights: {
          recommendations: [
            'Periksa kembali data input yang diberikan',
            'Pastikan produk terdaftar dengan benar dalam sistem',
            'Hubungi administrator jika masalah berlanjut',
          ],
          alerts: [
            {
              type: 'prediction_error',
              severity: 'medium',
              message: 'Prediksi gagal dibuat. Sistem akan menggunakan data historis sebagai fallback.',
            },
          ],
        },
      };
    }
  }

  /**
   * Generate batch predictions for multiple products
   */
  async batchPredict(
    tenantId: string,
    request: BatchPredictionRequest,
  ): Promise<Record<string, PredictionResult>> {
    this.logger.debug(
      `Generating batch predictions for ${
        request.productIds?.length || 0
      } products`,
    );

    const results: Record<string, PredictionResult> = {};

    if (!request.productIds?.length) {
      return results;
    }

    // Process predictions in parallel
    const promises = request.productIds.map(async productId => {
      const productRequest: PredictionRequest = {
        modelId: request.modelId,
        productId,
        predictionType: request.predictionType,
        targetDate: request.targetDate,
        forecastDays: request.forecastDays,
      };

      const result = await this.predict(tenantId, productRequest);
      return { productId, result };
    });

    const batchResults = await Promise.allSettled(promises);

    for (const settled of batchResults) {
      if (settled.status === 'fulfilled') {
        const { productId, result } = settled.value;
        results[productId] = result;
      } else {
        this.logger.error(
          `Batch prediction failed for a product: ${settled.reason}`,
        );
      }
    }

    return results;
  }

  /**
   * Get demand forecast for a product
   */
  async getDemandForecast(
    tenantId: string,
    productId: string,
    days: number = 30,
  ): Promise<PredictionResult> {
    return this.predict(tenantId, {
      productId,
      predictionType: PredictionType.DEMAND_FORECAST,
      forecastDays: days,
      includeConfidenceInterval: true,
    });
  }

  /**
   * Calculate stockout risk for a product
   */
  async getStockoutRisk(
    tenantId: string,
    productId: string,
    daysAhead: number = 7,
  ): Promise<PredictionResult> {
    const targetDate = moment().add(daysAhead, 'days').toDate();

    return this.predict(tenantId, {
      productId,
      predictionType: PredictionType.STOCKOUT_RISK,
      targetDate,
      forecastDays: 1,
    });
  }

  /**
   * Get optimal reorder recommendations
   */
  async getOptimalReorder(
    tenantId: string,
    productId: string,
  ): Promise<PredictionResult> {
    return this.predict(tenantId, {
      productId,
      predictionType: PredictionType.OPTIMAL_REORDER,
      forecastDays: 1,
    });
  }

  /**
   * Validate predictions against actual values
   */
  async validatePredictions(
    tenantId: string,
    startDate: Date,
    endDate: Date,
  ): Promise<{
    totalPredictions: number;
    accuratePredictions: number;
    averageErrorRate: number;
    modelPerformance: Record<string, any>;
  }> {
    this.logger.debug('Validating predictions against actual values');

    const predictions = await this.predictionRepo.find({
      where: {
        tenantId,
        targetDate: Between(startDate, endDate),
        status: PredictionStatus.COMPLETED,
      },
      relations: ['model'],
    });

    // Get actual sales data for validation
    const actualData = await this.dataPipelineService.extractTimeSeries(
      tenantId,
      {
        dateRange: {
          from: startDate.toISOString(),
          to: endDate.toISOString(),
        },
        aggregation: 'daily',
        features: ['sales'],
        target: 'quantity',
      },
    );

    // Create lookup for actual values
    const actualLookup = new Map<string, number>();
    for (const data of actualData) {
      const key = `${data.productId}_${data.date}`;
      actualLookup.set(key, data.value);
    }

    let totalPredictions = 0;
    let accuratePredictions = 0;
    let totalErrorRate = 0;
    const modelPerformance: Record<string, any> = {};

    for (const prediction of predictions) {
      const key = `${prediction.productId}_${moment(
        prediction.targetDate,
      ).format('YYYY-MM-DD')}`;
      const actualValue = actualLookup.get(key);

      if (actualValue !== undefined) {
        prediction.actualize(actualValue);
        await this.predictionRepo.save(prediction);

        totalPredictions++;
        totalErrorRate += prediction.errorRate || 0;

        if (prediction.isAccurate) {
          accuratePredictions++;
        }

        // Track model performance
        const modelId = prediction.modelId;
        if (!modelPerformance[modelId]) {
          modelPerformance[modelId] = {
            total: 0,
            accurate: 0,
            totalError: 0,
            modelType: prediction.model?.modelType,
          };
        }

        modelPerformance[modelId].total++;
        modelPerformance[modelId].totalError += prediction.errorRate || 0;

        if (prediction.isAccurate) {
          modelPerformance[modelId].accurate++;
        }
      }
    }

    // Calculate final metrics
    Object.values(modelPerformance).forEach((perf: any) => {
      perf.accuracy = perf.total > 0 ? perf.accurate / perf.total : 0;
      perf.averageError = perf.total > 0 ? perf.totalError / perf.total : 0;
    });

    return {
      totalPredictions,
      accuratePredictions,
      averageErrorRate:
        totalPredictions > 0 ? totalErrorRate / totalPredictions : 0,
      modelPerformance,
    };
  }

  // Private helper methods

  private async findBestModel(
    tenantId: string,
    request: PredictionRequest,
  ): Promise<MLModel | null> {
    try {
      this.logger.debug(
        `Finding best model for tenant ${tenantId}, prediction type: ${request.predictionType}`,
      );

      const queryBuilder = this.mlModelRepo
        .createQueryBuilder('model')
        .where('model.tenantId = :tenantId', { tenantId })
        .andWhere('model.status = :status', { status: ModelStatus.DEPLOYED })
        .andWhere('model.isActive = :isActive', { isActive: true });

      // Filter by specific model if requested
      if (request.modelId) {
        queryBuilder.andWhere('model.id = :modelId', {
          modelId: request.modelId,
        });
      }

      // Filter by product/category/location with graceful fallback
      if (request.productId) {
        queryBuilder.andWhere(
          '(model.productId = :productId OR model.productId IS NULL)',
          { productId: request.productId },
        );
      }

      if (request.categoryId) {
        queryBuilder.andWhere(
          '(model.categoryId = :categoryId OR model.categoryId IS NULL)',
          { categoryId: request.categoryId },
        );
      }

      if (request.locationId) {
        queryBuilder.andWhere(
          '(model.locationId = :locationId OR model.locationId IS NULL)',
          { locationId: request.locationId },
        );
      }

      // Order by specificity (more specific models first) and performance
      queryBuilder
        .orderBy("model.performance->'mape'", 'ASC')
        .addOrderBy('model.lastPredictionAt', 'DESC');

      const models = await queryBuilder.getMany();

      if (models.length > 0) {
        this.logger.debug(
          `Found ${models.length} suitable models, using best performer: ${models[0].id}`,
        );
        return models[0];
      }

      // Fallback: Try to find any active model for this tenant
      this.logger.warn(
        `No specific model found for request, trying fallback models for tenant ${tenantId}`,
      );

      const fallbackModel = await this.mlModelRepo.findOne({
        where: {
          tenantId,
          status: ModelStatus.DEPLOYED,
          isActive: true,
        },
        order: {
          createdAt: 'DESC', // Use most recent model as fallback
        },
      });

      if (fallbackModel) {
        this.logger.log(
          `Using fallback model ${fallbackModel.id} for prediction`,
        );
      } else {
        this.logger.warn(
          `No suitable models found for tenant ${tenantId}`,
        );
      }

      return fallbackModel || null;
    } catch (error) {
      this.logger.error(
        `Error finding best model for tenant ${tenantId}: ${error.message}`,
        error.stack,
      );
      return null;
    }
  }

  private async loadModel(model: MLModel): Promise<any> {
    const cacheKey = `model_${model.id}`;

    if (this.modelCache.has(cacheKey)) {
      this.logger.debug(`Using cached model ${model.id}`);
      return this.modelCache.get(cacheKey);
    }

    try {
      this.logger.debug(`Loading model ${model.id} from path: ${model.modelPath}`);

      if (!model.modelPath) {
        throw new Error(`Model path tidak tersedia untuk model ${model.id}`);
      }

      if (!fs.existsSync(model.modelPath)) {
        throw new Error(`File model tidak ditemukan: ${model.modelPath}`);
      }

      const modelData = JSON.parse(fs.readFileSync(model.modelPath, 'utf8'));

      // Validate model data structure
      if (!modelData || typeof modelData !== 'object') {
        throw new Error(`Format data model tidak valid untuk model ${model.id}`);
      }

      // Cache model for 1 hour
      this.modelCache.set(cacheKey, modelData);
      this.logger.debug(`Model ${model.id} berhasil dimuat dan disimpan dalam cache`);

      // Clean cache periodically
      setTimeout(() => {
        this.modelCache.delete(cacheKey);
        this.logger.debug(`Model ${model.id} dihapus dari cache`);
      }, 3600000); // 1 hour

      return modelData;
    } catch (error) {
      this.logger.error(
        `Gagal memuat model ${model.id}: ${error.message}`,
        error.stack,
      );
      
      // For missing model files, try to create a fallback simple model
      if (error.message.includes('tidak ditemukan') || error.message.includes('not found')) {
        this.logger.warn(`Menggunakan model fallback sederhana untuk ${model.id}`);
        
        // Create a simple fallback model
        const fallbackModel = {
          type: 'linear_regression',
          weights: [1.0], // Simple 1:1 relationship
          intercept: 0.0,
          lastValues: [0],
          performance: { mape: 50 }, // Low confidence
        };
        
        // Cache the fallback model briefly
        this.modelCache.set(cacheKey, fallbackModel);
        setTimeout(() => {
          this.modelCache.delete(cacheKey);
        }, 300000); // 5 minutes only for fallback
        
        return fallbackModel;
      }
      
      throw error;
    }
  }

  private async prepareFeatures(
    tenantId: string,
    request: PredictionRequest,
  ): Promise<Record<string, any>> {
    const features: Record<string, any> = {};

    // Get product features if productId is provided
    if (request.productId) {
      const productFeatures =
        await this.dataPipelineService.extractFeatures(tenantId, [
          request.productId,
        ], {
          dateRange: {
            from: moment().subtract(30, 'days').toISOString(),
            to: moment().toISOString(),
          },
          aggregation: 'daily',
          features: ['price', 'cost', 'category', 'supplier'],
          target: 'quantity',
        });

      if (productFeatures[0]) {
        Object.assign(
          features,
          productFeatures[0].productFeatures,
        );
        Object.assign(
          features,
          productFeatures[0].inventoryFeatures,
        );
      }
    }

    // Add temporal features
    const targetDate = request.targetDate || new Date();
    const momentDate = moment(targetDate);

    features.dayOfWeek = momentDate.day();
    features.dayOfMonth = momentDate.date();
    features.month = momentDate.month() + 1;
    features.quarter = momentDate.quarter();
    features.isWeekend =
      momentDate.day() === 0 || momentDate.day() === 6 ? 1 : 0;
    features.isMonthEnd = momentDate.date() > 25 ? 1 : 0;
    features.isQuarterEnd =
      momentDate.month() % 3 === 2 && momentDate.date() > 25 ? 1 : 0;

    // Add any custom features from request
    if (request.features) {
      Object.assign(features, request.features);
    }

    return features;
  }

  private async generatePrediction(
    model: any,
    features: Record<string, any>,
    forecastDays: number,
  ): Promise<number> {
    switch (model.type) {
      case 'linear_regression':
        return this.predictLinearRegression(model, features);

      case 'exponential_smoothing':
        return this.predictExponentialSmoothing(model, forecastDays);

      case 'arima':
        return this.predictRealARIMA(model, features, forecastDays);

      case 'prophet':
        return this.predictRealProphet(model, features, forecastDays);

      case 'xgboost':
        return this.predictRealXGBoost(model, features, forecastDays);

      default:
        throw new Error(`Unsupported model type: ${model.type}`);
    }
  }

  private predictLinearRegression(
    model: any,
    features: Record<string, any>,
  ): number {
    const featureVector = model.weights.map((weight: number, index: number) => {
      const featureValue = Object.values(features)[index] || 0;
      return weight * (typeof featureValue === 'number' ? featureValue : 0);
    });

    const prediction =
      featureVector.reduce((sum: number, val: number) => sum + val, 0) +
      model.intercept;
    return Math.max(0, prediction); // Ensure non-negative predictions
  }

  private predictExponentialSmoothing(
    model: any,
    forecastDays: number,
  ): number {
    // Use the last value from training as baseline
    const lastValue = model.lastValues[model.lastValues.length - 1] || 0;

    // Simple forecast using the smoothing parameters
    // In a real implementation, this would use the full Holt-Winters equations
    return Math.max(0, lastValue);
  }

  /**
   * Real ARIMA prediction replacing the previous stub implementation
   * Now uses actual statistical ARIMA modeling via Python service
   */
  private async predictRealARIMA(
    model: any,
    features: Record<string, any>,
    forecastDays: number,
  ): Promise<number> {
    try {
      this.logger.debug(`Generating real ARIMA prediction for ${forecastDays} days`);

      // Extract historical data from model
      const historicalData = model.historicalData || model.lastValues || [];
      
      if (historicalData.length < 10) {
        this.logger.warn(`Insufficient historical data for ARIMA (${historicalData.length} points), using fallback`);
        return this.predictLinearRegressionFallback(model, features);
      }

      // Call real ARIMA implementation
      const arimaResult = await this.realMLService.predictRealARIMA(
        historicalData,
        forecastDays
      );

      if (arimaResult.success && arimaResult.predictedValue !== undefined) {
        this.logger.debug(`Real ARIMA prediction successful: ${arimaResult.predictedValue} (confidence: ${arimaResult.confidence})`);
        return arimaResult.predictedValue;
      } else {
        this.logger.warn(`Real ARIMA prediction failed: ${arimaResult.error}, using fallback`);
        return this.predictLinearRegressionFallback(model, features);
      }

    } catch (error) {
      this.logger.error(`Real ARIMA prediction error: ${error.message}`, error.stack);
      
      // Graceful fallback to simple prediction
      return this.predictLinearRegressionFallback(model, features);
    }
  }

  /**
   * Fallback prediction method when ARIMA fails
   */
  private predictLinearRegressionFallback(model: any, features: Record<string, any>): number {
    const lastValues = model.lastValues || [0];
    const lastValue = lastValues[lastValues.length - 1] || 0;
    
    // Simple trend-based prediction
    if (lastValues.length >= 2) {
      const trend = lastValues[lastValues.length - 1] - lastValues[lastValues.length - 2];
      return Math.max(0, lastValue + trend);
    }
    
    return Math.max(0, lastValue);
  }

  /**
   * Real Prophet prediction for seasonal forecasting
   * Uses Facebook Prophet for advanced seasonal and trend analysis
   */
  private async predictRealProphet(
    model: any,
    features: Record<string, any>,
    forecastDays: number,
  ): Promise<number> {
    try {
      this.logger.debug(`Generating real Prophet prediction for ${forecastDays} days`);

      // Extract historical data from model
      const historicalData = model.historicalData || model.lastValues || [];
      const dates = model.dates || null;
      
      if (historicalData.length < 10) {
        this.logger.warn(`Insufficient historical data for Prophet (${historicalData.length} points), using fallback`);
        return this.predictLinearRegressionFallback(model, features);
      }

      // Prepare seasonality configuration based on model configuration
      const seasonalityConfig = {
        yearly_seasonality: model.config?.yearly_seasonality !== false,
        weekly_seasonality: model.config?.weekly_seasonality !== false,
        daily_seasonality: model.config?.daily_seasonality === true,
        seasonality_mode: model.config?.seasonality_mode || 'multiplicative',
        growth: model.config?.growth || 'linear'
      };

      // Call real Prophet implementation
      const prophetResult = await this.realMLService.predictRealProphet(
        historicalData,
        forecastDays,
        dates,
        seasonalityConfig
      );

      if (prophetResult.success && prophetResult.predictedValue !== undefined) {
        this.logger.debug(`Real Prophet prediction successful: ${prophetResult.predictedValue} (confidence: ${prophetResult.confidence})`);
        return prophetResult.predictedValue;
      } else {
        this.logger.warn(`Real Prophet prediction failed: ${prophetResult.error}, using fallback`);
        return this.predictLinearRegressionFallback(model, features);
      }

    } catch (error) {
      this.logger.error(`Real Prophet prediction error: ${error.message}`, error.stack);
      
      // Graceful fallback to simple prediction
      return this.predictLinearRegressionFallback(model, features);
    }
  }

  /**
   * Real XGBoost prediction for multi-feature ensemble forecasting
   * Uses gradient boosting with comprehensive feature engineering
   */
  private async predictRealXGBoost(
    model: any,
    features: Record<string, any>,
    forecastDays: number,
  ): Promise<number> {
    try {
      this.logger.debug(`Generating real XGBoost prediction for ${forecastDays} days`);

      // Extract historical data from model
      const historicalData = model.historicalData || model.lastValues || [];
      const dates = model.dates || null;
      
      if (historicalData.length < 15) {
        this.logger.warn(`Insufficient historical data for XGBoost (${historicalData.length} points), using fallback`);
        return this.predictLinearRegressionFallback(model, features);
      }

      // Prepare external features for XGBoost
      const externalFeatures: Record<string, any[]> = {};
      
      // Include current features as external features for prediction
      Object.keys(features).forEach(key => {
        if (typeof features[key] === 'number') {
          // For single values, create an array matching historical data length
          externalFeatures[key] = new Array(historicalData.length).fill(features[key]);
        }
      });

      // Hyperparameter configuration from model
      const hyperparameterConfig = model.config?.hyperparameters || null;

      // Call real XGBoost implementation
      const xgboostResult = await this.realMLService.predictRealXGBoost(
        historicalData,
        forecastDays,
        dates,
        externalFeatures,
        hyperparameterConfig
      );

      if (xgboostResult.success && xgboostResult.predictedValue !== undefined) {
        this.logger.debug(`Real XGBoost prediction successful: ${xgboostResult.predictedValue} (confidence: ${xgboostResult.confidence})`);
        return xgboostResult.predictedValue;
      } else {
        this.logger.warn(`Real XGBoost prediction failed: ${xgboostResult.error}, using fallback`);
        return this.predictLinearRegressionFallback(model, features);
      }

    } catch (error) {
      this.logger.error(`Real XGBoost prediction error: ${error.message}`, error.stack);
      
      // Graceful fallback to simple prediction
      return this.predictLinearRegressionFallback(model, features);
    }
  }

  private calculateConfidence(
    model: MLModel,
    features: Record<string, any>,
  ): number {
    // Base confidence on model performance
    const baseConfidence = model.performance
      ? 1 - model.performance.mape / 100
      : 0.5;

    // Adjust confidence based on feature completeness
    const expectedFeatures = model.trainingConfig?.features?.length || 1;
    const providedFeatures = Object.keys(features).length;
    const featureCompleteness = Math.min(
      1,
      providedFeatures / expectedFeatures,
    );

    // Adjust confidence based on model age
    const ageAdjustment = Math.max(0.7, 1 - model.modelAge / 365); // Reduce confidence for old models

    return Math.max(
      0.1,
      Math.min(1, baseConfidence * featureCompleteness * ageAdjustment),
    );
  }

  private calculateConfidenceBounds(
    prediction: number,
    confidence: number,
  ): { lower: number; upper: number } {
    // Calculate bounds based on confidence level
    const errorMargin = prediction * (1 - confidence) * 0.5;

    return {
      lower: Math.max(0, prediction - errorMargin),
      upper: prediction + errorMargin,
    };
  }

  private async generateTimeSeriesForecast(
    model: any,
    features: Record<string, any>,
    days: number,
  ): Promise<
    Array<{
      date: string;
      value: number;
      lowerBound?: number;
      upperBound?: number;
    }>
  > {
    // For Prophet models, try to get full time series from the model itself
    if (model.type === 'prophet') {
      try {
        const historicalData = model.historicalData || model.lastValues || [];
        const dates = model.dates || null;
        
        if (historicalData.length >= 10) {
          const prophetResult = await this.realMLService.predictRealProphet(
            historicalData,
            days,
            dates
          );
          
          if (prophetResult.success && prophetResult.timeSeries) {
            return prophetResult.timeSeries.map(ts => ({
              date: ts.date,
              value: ts.value,
              lowerBound: ts.lowerBound,
              upperBound: ts.upperBound
            }));
          }
        }
      } catch (error) {
        this.logger.warn(`Prophet time series generation failed, falling back to day-by-day: ${error.message}`);
      }
    }

    // For XGBoost models, try to get full time series with feature engineering
    if (model.type === 'xgboost') {
      try {
        const historicalData = model.historicalData || model.lastValues || [];
        const dates = model.dates || null;
        
        if (historicalData.length >= 15) {
          // Prepare external features for XGBoost time series
          const externalFeatures: Record<string, any[]> = {};
          Object.keys(features).forEach(key => {
            if (typeof features[key] === 'number') {
              externalFeatures[key] = new Array(historicalData.length).fill(features[key]);
            }
          });

          const xgboostResult = await this.realMLService.predictRealXGBoost(
            historicalData,
            days,
            dates,
            externalFeatures
          );
          
          if (xgboostResult.success && xgboostResult.timeSeries) {
            return xgboostResult.timeSeries.map(ts => ({
              date: ts.date,
              value: ts.value,
              lowerBound: ts.lowerBound,
              upperBound: ts.upperBound
            }));
          }
        }
      } catch (error) {
        this.logger.warn(`XGBoost time series generation failed, falling back to day-by-day: ${error.message}`);
      }
    }

    // Fallback: Generate day-by-day predictions for all other models or when Prophet fails
    const timeSeries = [];
    const baseDate = moment();

    for (let i = 0; i < days; i++) {
      const date = baseDate.clone().add(i, 'days');

      // Generate prediction for this date
      const dayFeatures = {
        ...features,
        dayOfWeek: date.day(),
        dayOfMonth: date.date(),
        month: date.month() + 1,
        quarter: date.quarter(),
        isWeekend: date.day() === 0 || date.day() === 6 ? 1 : 0,
      };

      const value = await this.generatePrediction(model, dayFeatures, 1);
      const confidence = this.calculateConfidence(
        { performance: { mape: 10 } } as any,
        dayFeatures,
      );
      const bounds = this.calculateConfidenceBounds(value, confidence);

      timeSeries.push({
        date: date.format('YYYY-MM-DD'),
        value,
        lowerBound: bounds.lower,
        upperBound: bounds.upper,
      });
    }

    return timeSeries;
  }

  private async generateActionableInsights(
    tenantId: string,
    prediction: Prediction,
    model: MLModel,
  ): Promise<{
    recommendations?: string[];
    alerts?: Array<{
      type: string;
      severity: 'low' | 'medium' | 'high' | 'critical';
      message: string;
    }>;
  }> {
    const insights: any = {
      recommendations: [],
      alerts: [],
    };

    // Generate insights based on prediction type
    switch (prediction.predictionType) {
      case PredictionType.DEMAND_FORECAST:
        await this.generateDemandForecastInsights(
          tenantId,
          prediction,
          insights,
        );
        break;

      case PredictionType.STOCKOUT_RISK:
        await this.generateStockoutRiskInsights(tenantId, prediction, insights);
        break;

      case PredictionType.OPTIMAL_REORDER:
        await this.generateReorderInsights(tenantId, prediction, insights);
        break;
    }

    // Add confidence-based insights with Indonesian localization
    if (prediction.confidence < 0.7) {
      insights.alerts.push({
        type: 'low_confidence',
        severity: 'medium',
        message: `Prediksi memiliki tingkat kepercayaan rendah (${(prediction.confidence * 100).toFixed(0)}%). Pertimbangkan untuk mengumpulkan lebih banyak data historis.`,
      });

      insights.recommendations.push(
        'Tingkatkan kualitas data dengan mencatat transaksi secara konsisten',
        'Tunggu 2-4 minggu untuk akumulasi data yang lebih baik',
        'Verifikasi data yang sudah ada untuk memastikan akurasi',
      );
    }

    // Add model performance insights
    if (prediction.confidence > 0.8) {
      insights.recommendations.push(
        `Prediksi memiliki tingkat kepercayaan tinggi (${(prediction.confidence * 100).toFixed(0)}%) - hasil dapat diandalkan untuk pengambilan keputusan`,
      );
    }

    return insights;
  }

  private async generateDemandForecastInsights(
    tenantId: string,
    prediction: Prediction,
    insights: any,
  ): Promise<void> {
    const predictedDemand = prediction.predictedValue;

    // Get current inventory
    if (prediction.productId) {
      const currentStock = await this.getCurrentStock(
        tenantId,
        prediction.productId,
      );

      if (currentStock < predictedDemand) {
        const shortage = predictedDemand - currentStock;
        insights.alerts.push({
          type: 'stock_shortage',
          severity: shortage > predictedDemand * 0.5 ? 'critical' : 'high',
          message: `Stok saat ini (${currentStock}) tidak mencukupi untuk memenuhi prediksi permintaan (${predictedDemand.toFixed(
            0,
          )}). Kekurangan: ${shortage.toFixed(0)} unit.`,
        });

        insights.recommendations.push(
          `Segera lakukan restok untuk ${Math.ceil(
            shortage,
          )} unit untuk memenuhi prediksi permintaan.`,
        );
      }
    }

    // Seasonal insights
    if (prediction.predictionData?.seasonalComponents) {
      insights.recommendations.push(
        'Perhatikan pola musiman dalam perencanaan stok.',
      );
    }
  }

  private async generateStockoutRiskInsights(
    tenantId: string,
    prediction: Prediction,
    insights: any,
  ): Promise<void> {
    const riskScore = prediction.predictedValue;

    if (riskScore > 0.7) {
      insights.alerts.push({
        type: 'high_stockout_risk',
        severity: 'critical',
        message: `Risiko kehabisan stok sangat tinggi (${(
          riskScore * 100
        ).toFixed(0)}%). Tindakan segera diperlukan.`,
      });

      insights.recommendations.push(
        'Segera lakukan pemesanan darurat untuk mencegah kehabisan stok.',
      );
    } else if (riskScore > 0.4) {
      insights.alerts.push({
        type: 'medium_stockout_risk',
        severity: 'medium',
        message: `Risiko kehabisan stok sedang (${(riskScore * 100).toFixed(
          0,
        )}%). Pertimbangkan untuk melakukan restok.`,
      });
    }
  }

  private async generateReorderInsights(
    tenantId: string,
    prediction: Prediction,
    insights: any,
  ): Promise<void> {
    const optimalQuantity = prediction.predictedValue;

    insights.recommendations.push(
      `Jumlah pemesanan optimal: ${Math.ceil(optimalQuantity)} unit.`,
    );

    if (optimalQuantity > 1000) {
      insights.recommendations.push(
        'Pertimbangkan untuk bernegosiasi diskon volume dengan pemasok.',
      );
    }
  }

  private async calculateBusinessImpact(
    tenantId: string,
    prediction: Prediction,
  ): Promise<{
    revenueImpact?: number;
    costImpact?: number;
    stockoutRisk?: number;
    overstockRisk?: number;
  }> {
    const impact: any = {};

    if (prediction.productId) {
      const product = await this.productRepo.findOne({
        where: { id: prediction.productId, tenantId },
      });

      if (product) {
        // Calculate revenue impact
        impact.revenueImpact = prediction.predictedValue * product.sellingPrice;

        // Calculate cost impact
        impact.costImpact = prediction.predictedValue * product.costPrice;

        // Simple risk calculations
        const currentStock = await this.getCurrentStock(
          tenantId,
          prediction.productId,
        );
        const demandRatio = currentStock / (prediction.predictedValue || 1);

        impact.stockoutRisk =
          demandRatio < 0.5 ? 0.8 : demandRatio < 1 ? 0.4 : 0.1;
        impact.overstockRisk =
          demandRatio > 3 ? 0.7 : demandRatio > 2 ? 0.3 : 0.1;
      }
    }

    return impact;
  }

  private async getCurrentStock(
    tenantId: string,
    productId: string,
  ): Promise<number> {
    try {
      this.logger.debug(
        `Getting current stock for product ${productId} in tenant ${tenantId}`,
      );

      // Get sum of all inventory quantities for this product across all locations
      const result = await this.inventoryItemRepo
        .createQueryBuilder('inventory')
        .select('SUM(inventory.quantityOnHand)', 'totalStock')
        .where('inventory.tenantId = :tenantId', { tenantId })
        .andWhere('inventory.productId = :productId', { productId })
        .getRawOne();

      const totalStock = result?.totalStock || 0;
      
      this.logger.debug(
        `Current stock for product ${productId}: ${totalStock} units`,
      );

      return Number(totalStock) || 0;
    } catch (error) {
      this.logger.error(
        `Failed to get current stock for product ${productId}: ${error.message}`,
        error.stack,
      );
      
      // Return 0 as safe fallback instead of throwing
      return 0;
    }
  }

  private buildCacheKey(
    tenantId: string,
    request: PredictionRequest,
    modelId: string,
  ): string {
    const keyParts = [
      tenantId,
      modelId,
      request.productId || 'all',
      request.predictionType,
      request.targetDate?.toISOString().split('T')[0] || 'now',
      request.forecastDays || 1,
    ];

    return `prediction_${keyParts.join('_')}`;
  }

  /**
   * Get localized error message for Indonesian users
   */
  private getLocalizedErrorMessage(error: any): string {
    const errorMessage = error.message || 'Unknown error';

    // Map common errors to Indonesian messages
    const errorMappings: Record<string, string> = {
      'No suitable model found': 'Model prediksi yang sesuai tidak ditemukan',
      'Model file not found': 'File model tidak ditemukan dalam sistem',
      'Failed to load model': 'Gagal memuat model prediksi',
      'Database connection error': 'Koneksi database bermasalah',
      'Insufficient data': 'Data tidak mencukupi untuk prediksi',
      'Invalid product ID': 'ID produk tidak valid',
      'Feature extraction failed': 'Gagal mengekstrak fitur data',
      'Prediction calculation failed': 'Perhitungan prediksi gagal',
    };

    // Check for specific error patterns
    for (const [pattern, indonesianMessage] of Object.entries(errorMappings)) {
      if (errorMessage.toLowerCase().includes(pattern.toLowerCase())) {
        return indonesianMessage;
      }
    }

    // Fallback to generic Indonesian error message
    return `Terjadi kesalahan dalam sistem prediksi: ${errorMessage}`;
  }
}
