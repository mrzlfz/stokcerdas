import { Injectable, Logger, BadRequestException } from '@nestjs/common';
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import { Inject } from '@nestjs/common';
import { Cache } from 'cache-manager';
import { EventEmitter2 } from '@nestjs/event-emitter';
import * as moment from 'moment-timezone';
import { InjectDataSource } from '@nestjs/typeorm';
import { DataSource } from 'typeorm';
import { ConfigService } from '@nestjs/config';

import { TimeSeriesDataPoint } from './data-pipeline.service';
import {
  InventoryHistoryPoint,
  ProductLifecyclePoint,
  OrderPatternPoint,
  ExternalDataPoint,
} from './historical-data-extraction.service';
import { SeasonalityAlgorithmsService } from './seasonality-algorithms.service';

export interface SeasonalityLearningRequest {
  jobId: string;
  tenantId: string;
  data: {
    sales?: TimeSeriesDataPoint[];
    inventory?: InventoryHistoryPoint[];
    products?: ProductLifecyclePoint[];
    orders?: OrderPatternPoint[];
    external?: ExternalDataPoint[];
  };
  learningConfig: {
    methods: ('fourier' | 'stl' | 'x13' | 'wavelet' | 'ensemble')[];
    detectionSensitivity: 'low' | 'medium' | 'high' | 'adaptive';
    minPeriodLength: number; // minimum days for a pattern
    maxPeriodLength: number; // maximum days for a pattern
    confidenceThreshold: number; // 0-1, minimum confidence for pattern
    adaptiveUpdates: boolean;
    indonesianContext: boolean;
  };
  businessContext: {
    industry: string;
    businessType: 'retail' | 'wholesale' | 'manufacturing' | 'service';
    operatingDays: number[]; // 0=Sunday, 1=Monday, etc.
    seasonalEvents: IndonesianBusinessEvent[];
    customPeriods: CustomSeasonalPeriod[];
  };
  validationConfig: {
    backtestPeriods: number;
    validationMethod: 'holdout' | 'rolling' | 'expanding';
    accuracyMetrics: ('mae' | 'rmse' | 'mape' | 'smape')[];
    minimumAccuracy: number;
  };
}

export interface IndonesianBusinessEvent {
  name: string;
  type: 'national_holiday' | 'religious' | 'cultural' | 'business_cycle' | 'economic';
  dates: string[]; // ISO dates or cron-like patterns
  impact: 'positive' | 'negative' | 'neutral';
  magnitude: number; // 0-1, strength of impact
  duration: number; // days of impact
  leadTime: number; // days before event when impact starts
  lagTime: number; // days after event when impact continues
  region?: 'national' | 'java' | 'sumatra' | 'kalimantan' | 'sulawesi' | 'papua';
  businessImpact: {
    sales: number; // multiplier effect
    inventory: number;
    demand: number;
    supply: number;
  };
}

export interface CustomSeasonalPeriod {
  name: string;
  periodType: 'weekly' | 'monthly' | 'quarterly' | 'yearly' | 'custom';
  pattern: number[]; // seasonal indices
  strength: number; // 0-1, how strong the seasonality is
  confidence: number; // 0-1, confidence in the pattern
  applicableProducts?: string[];
  applicableCategories?: string[];
  validFrom: string;
  validTo?: string;
}

export interface SeasonalityLearningResult {
  jobId: string;
  status: 'completed' | 'partial' | 'failed' | 'learning';
  overallSeasonality: SeasonalityStrength;
  detectedPatterns: DetectedSeasonalPattern[];
  learnedModels: LearnedSeasonalModel[];
  indonesianPatterns: IndonesianSeasonalInsight[];
  validation: SeasonalityValidation;
  adaptiveConfig: AdaptiveSeasonalityConfig;
  recommendations: SeasonalityRecommendation[];
  warnings: string[];
  errors: string[];
  metadata: {
    processingTime: number;
    patternsDetected: number;
    modelsLearned: number;
    accuracyAchieved: number;
    nextLearningScheduled: string;
    dataQualityScore: number;
  };
}

export interface SeasonalityStrength {
  overall: number; // 0-1, overall seasonality strength
  weekly: number;
  monthly: number;
  quarterly: number;
  yearly: number;
  custom: Record<string, number>;
  dominant: 'weekly' | 'monthly' | 'quarterly' | 'yearly' | 'custom' | 'none';
  confidence: number;
  stability: number; // how stable the seasonality is over time
}

export interface DetectedSeasonalPattern {
  id: string;
  name: string;
  type: 'weekly' | 'monthly' | 'quarterly' | 'yearly' | 'custom' | 'event_driven';
  period: number; // length in appropriate units
  strength: number; // 0-1, how strong the pattern is
  confidence: number; // 0-1, statistical confidence
  stability: number; // 0-1, how stable over time
  phase: number; // offset within the period
  amplitude: number; // magnitude of variation
  trend: number; // underlying trend component
  method: string; // detection method used
  discovered: string; // ISO date when discovered
  lastUpdated: string; // ISO date of last update
  validationScore: number; // 0-1, how well it validates
  businessRelevance: number; // 0-1, business importance
  dataPoints: SeasonalDataPoint[];
  statistics: {
    mean: number;
    variance: number;
    autocorrelation: number[];
    spectralDensity: number[];
    decomposeSTL?: {
      trend: number[];
      seasonal: number[];
      remainder: number[];
    };
  };
}

export interface SeasonalDataPoint {
  timestamp: string;
  value: number;
  seasonalIndex: number; // -1 to 1, seasonal effect
  deseasonalized: number; // value with seasonality removed
  confidence: number;
  outlier: boolean;
}

export interface LearnedSeasonalModel {
  id: string;
  name: string;
  type: 'fourier' | 'stl' | 'x13' | 'wavelet' | 'neural' | 'ensemble';
  parameters: Record<string, any>;
  trainingData: {
    startDate: string;
    endDate: string;
    observations: number;
    quality: number;
  };
  performance: {
    accuracy: number;
    precision: number;
    recall: number;
    f1Score: number;
    backtestResults: BacktestResult[];
  };
  seasonalComponents: SeasonalComponent[];
  forecastingCapability: {
    horizon: number; // maximum forecast periods
    confidence: number; // forecast confidence
    updateFrequency: string; // how often to retrain
  };
  indonesianAdaptations: {
    holidayEffects: Record<string, number>;
    ramadanEffect: number;
    hariBesarEffects: Record<string, number>;
    regionalAdjustments: Record<string, number>;
    businessCycleIntegration: boolean;
  };
}

export interface SeasonalComponent {
  name: string;
  type: 'additive' | 'multiplicative';
  frequency: number;
  harmonics: number[];
  coefficients: number[];
  significance: number; // p-value or similar
  contribution: number; // % of total seasonal effect
}

export interface BacktestResult {
  period: string;
  actualValues: number[];
  predictedValues: number[];
  seasonalPredictions: number[];
  errors: number[];
  metrics: {
    mae: number;
    rmse: number;
    mape: number;
    smape: number;
  };
  confidence: number;
}

export interface IndonesianSeasonalInsight {
  category: 'religious' | 'cultural' | 'economic' | 'weather' | 'regulatory';
  name: string;
  description: string;
  impact: 'high' | 'medium' | 'low';
  timing: {
    start: string; // month-day or specific pattern
    duration: number; // days
    repeatPattern: 'yearly' | 'lunar' | 'custom';
  };
  businessEffect: {
    sales: number; // multiplier
    inventory: number;
    demandShift: number;
    priceElasticity: number;
  };
  recommendations: string[];
  historicalEvidence: {
    years: number[];
    averageImpact: number;
    confidence: number;
    consistency: number;
  };
  regionalVariations: Record<string, number>;
}

export interface SeasonalityValidation {
  method: 'holdout' | 'rolling' | 'expanding' | 'cross_validation';
  periods: number;
  results: ValidationResult[];
  overallAccuracy: number;
  stabilityScore: number;
  robustnessScore: number;
  recommendations: string[];
}

export interface ValidationResult {
  period: string;
  method: string;
  accuracy: number;
  seasonalAccuracy: number;
  trendAccuracy: number;
  residualAnalysis: {
    autocorrelation: number[];
    normality: number; // Shapiro-Wilk p-value
    heteroscedasticity: number; // Breusch-Pagan p-value
    stationarity: number; // ADF test p-value
  };
}

export interface AdaptiveSeasonalityConfig {
  enabled: boolean;
  updateFrequency: 'daily' | 'weekly' | 'monthly' | 'quarterly';
  adaptationRate: number; // 0-1, how quickly to adapt
  minimumDataPoints: number;
  significanceThreshold: number;
  memoryLength: number; // periods to remember
  forgettingFactor: number; // exponential smoothing parameter
  triggerThresholds: {
    accuracyDrop: number; // when to trigger relearning
    patternShift: number; // when pattern significantly changes
    newDataVolume: number; // when enough new data is available
  };
  indonesianAdaptations: {
    holidayLearning: boolean;
    economicIndicatorIntegration: boolean;
    regionalAdaptation: boolean;
    culturalEventTracking: boolean;
  };
}

export interface SeasonalityRecommendation {
  id: string;
  type: 'pattern_improvement' | 'model_optimization' | 'data_collection' | 'business_strategy';
  priority: 'high' | 'medium' | 'low';
  title: string;
  description: string;
  expectedImpact: number; // 0-1, expected improvement
  implementationEffort: 'low' | 'medium' | 'high';
  timeline: string;
  prerequisites: string[];
  businessValue: string;
  technicalDetails: Record<string, any>;
  indonesianContext?: string;
}

@Injectable()
export class AdaptiveSeasonalityService {
  private readonly logger = new Logger(AdaptiveSeasonalityService.name);

  constructor(
    @Inject(CACHE_MANAGER) private cacheManager: Cache,
    private readonly eventEmitter: EventEmitter2,
    @InjectDataSource() private readonly dataSource: DataSource,
    private readonly configService: ConfigService,
    private readonly algorithmsService: SeasonalityAlgorithmsService,
  ) {}

  async learnSeasonalPatterns(request: SeasonalityLearningRequest): Promise<SeasonalityLearningResult> {
    const startTime = Date.now();
    this.logger.log(`Starting seasonality learning for job ${request.jobId}`);

    try {
      // Initialize result structure
      const result: SeasonalityLearningResult = {
        jobId: request.jobId,
        status: 'learning',
        overallSeasonality: {
          overall: 0,
          weekly: 0,
          monthly: 0,
          quarterly: 0,
          yearly: 0,
          custom: {},
          dominant: 'none',
          confidence: 0,
          stability: 0,
        },
        detectedPatterns: [],
        learnedModels: [],
        indonesianPatterns: [],
        validation: {
          method: request.validationConfig.validationMethod,
          periods: request.validationConfig.backtestPeriods,
          results: [],
          overallAccuracy: 0,
          stabilityScore: 0,
          robustnessScore: 0,
          recommendations: [],
        },
        adaptiveConfig: await this.createAdaptiveConfig(request),
        recommendations: [],
        warnings: [],
        errors: [],
        metadata: {
          processingTime: 0,
          patternsDetected: 0,
          modelsLearned: 0,
          accuracyAchieved: 0,
          nextLearningScheduled: '',
          dataQualityScore: 0,
        },
      };

      // Step 1: Preprocess and validate data
      const preprocessedData = await this.preprocessSeasonalityData(request.data, request.businessContext);
      result.metadata.dataQualityScore = preprocessedData.qualityScore;

      if (preprocessedData.qualityScore < 0.5) {
        result.warnings.push('Data quality score is low, seasonality detection may be unreliable');
      }

      // Step 2: Detect seasonal patterns using multiple methods
      result.detectedPatterns = await this.detectSeasonalPatterns(
        preprocessedData.data,
        request.learningConfig,
        request.businessContext,
      );

      // Step 3: Learn seasonal models
      result.learnedModels = await this.learnSeasonalModels(
        preprocessedData.data,
        result.detectedPatterns,
        request.learningConfig,
      );

      // Step 4: Indonesian-specific pattern analysis
      result.indonesianPatterns = await this.analyzeIndonesianPatterns(
        preprocessedData.data,
        request.businessContext,
        result.detectedPatterns,
      );

      // Step 5: Calculate overall seasonality strength
      result.overallSeasonality = await this.calculateSeasonalityStrength(
        result.detectedPatterns,
        result.learnedModels,
      );

      // Step 6: Validate learned patterns
      result.validation = await this.validateSeasonalPatterns(
        preprocessedData.data,
        result.learnedModels,
        request.validationConfig,
      );

      // Step 7: Generate recommendations
      result.recommendations = await this.generateSeasonalityRecommendations(
        result,
        request,
        preprocessedData,
      );

      // Step 8: Setup adaptive learning
      if (request.learningConfig.adaptiveUpdates) {
        await this.setupAdaptiveLearning(request.tenantId, result.adaptiveConfig);
      }

      // Finalize result
      result.status = result.validation.overallAccuracy > request.validationConfig.minimumAccuracy ? 'completed' : 'partial';
      result.metadata.processingTime = Date.now() - startTime;
      result.metadata.patternsDetected = result.detectedPatterns.length;
      result.metadata.modelsLearned = result.learnedModels.length;
      result.metadata.accuracyAchieved = result.validation.overallAccuracy;
      result.metadata.nextLearningScheduled = this.calculateNextLearningTime(result.adaptiveConfig);

      // Cache the result
      await this.cacheSeasonalityResult(request.tenantId, result);

      // Emit event for other services
      this.eventEmitter.emit('seasonality.learned', {
        tenantId: request.tenantId,
        jobId: request.jobId,
        patterns: result.detectedPatterns.length,
        accuracy: result.validation.overallAccuracy,
      });

      this.logger.log(`Seasonality learning completed for job ${request.jobId} in ${result.metadata.processingTime}ms`);

      return result;

    } catch (error) {
      this.logger.error(`Seasonality learning failed for job ${request.jobId}: ${error.message}`, error.stack);
      throw new BadRequestException(`Seasonality learning failed: ${error.message}`);
    }
  }

  private async preprocessSeasonalityData(
    data: SeasonalityLearningRequest['data'],
    businessContext: SeasonalityLearningRequest['businessContext'],
  ): Promise<{
    data: TimeSeriesDataPoint[];
    qualityScore: number;
    gaps: any[];
    outliers: any[];
    transformations: any[];
  }> {
    const startTime = Date.now();
    this.logger.log('Preprocessing data for seasonality learning');

    try {
      // Combine all data sources into unified time series
      const combinedData: TimeSeriesDataPoint[] = [];

      // Process sales data
      if (data.sales && data.sales.length > 0) {
        combinedData.push(...data.sales.map(point => ({
          ...point,
          source: 'sales',
        })));
      }

      // Process inventory data and convert to sales-like format
      if (data.inventory && data.inventory.length > 0) {
        data.inventory.forEach(point => {
          combinedData.push({
            timestamp: point.timestamp,
            value: point.stockLevel,
            productId: point.productId,
            locationId: point.locationId,
            tenantId: point.tenantId,
            source: 'inventory',
            metadata: {
              movementType: point.movementType,
              quantity: point.quantity,
            },
          });
        });
      }

      // Process order data
      if (data.orders && data.orders.length > 0) {
        data.orders.forEach(point => {
          combinedData.push({
            timestamp: point.timestamp,
            value: point.orderValue || point.quantity,
            productId: point.productId,
            locationId: point.locationId,
            tenantId: point.tenantId,
            source: 'orders',
            metadata: {
              orderId: point.orderId,
              customerId: point.customerId,
              channel: point.channel,
            },
          });
        });
      }

      // Sort data chronologically
      combinedData.sort((a, b) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());

      // Quality assessment
      const qualityAnalysis = this.assessDataQuality(combinedData, businessContext);

      // Handle missing data
      const filledData = this.fillMissingValues(combinedData, businessContext);

      // Remove outliers (but keep track of them)
      const { cleanData, outliers } = this.removeOutliers(filledData, businessContext);

      // Apply Indonesian business context transformations
      const transformedData = this.applyIndonesianTransformations(cleanData, businessContext);

      this.logger.log(`Data preprocessing completed in ${Date.now() - startTime}ms`);

      return {
        data: transformedData.data,
        qualityScore: qualityAnalysis.overallScore,
        gaps: qualityAnalysis.gaps,
        outliers: outliers,
        transformations: transformedData.transformations,
      };

    } catch (error) {
      this.logger.error(`Data preprocessing failed: ${error.message}`, error.stack);
      throw error;
    }
  }

  private assessDataQuality(
    data: TimeSeriesDataPoint[],
    businessContext: SeasonalityLearningRequest['businessContext'],
  ): {
    overallScore: number;
    completeness: number;
    consistency: number;
    regularity: number;
    gaps: any[];
    issues: string[];
  } {
    if (!data || data.length === 0) {
      return {
        overallScore: 0,
        completeness: 0,
        consistency: 0,
        regularity: 0,
        gaps: [],
        issues: ['No data provided'],
      };
    }

    const issues: string[] = [];
    const gaps: any[] = [];

    // Check completeness
    const dateRange = {
      start: new Date(data[0].timestamp),
      end: new Date(data[data.length - 1].timestamp),
    };
    const expectedDays = Math.ceil((dateRange.end.getTime() - dateRange.start.getTime()) / (1000 * 60 * 60 * 24));
    const actualDays = new Set(data.map(d => moment(d.timestamp).format('YYYY-MM-DD'))).size;
    const completeness = actualDays / expectedDays;

    // Check consistency
    const values = data.map(d => d.value).filter(v => v != null && !isNaN(v));
    const mean = values.reduce((a, b) => a + b, 0) / values.length;
    const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
    const coefficientOfVariation = Math.sqrt(variance) / Math.abs(mean);
    const consistency = Math.max(0, 1 - Math.min(coefficientOfVariation / 2, 1)); // Normalize to 0-1

    // Check regularity (time intervals)
    const intervals = [];
    for (let i = 1; i < data.length; i++) {
      const interval = new Date(data[i].timestamp).getTime() - new Date(data[i-1].timestamp).getTime();
      intervals.push(interval);
    }
    const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
    const intervalVariance = intervals.reduce((sum, int) => sum + Math.pow(int - avgInterval, 2), 0) / intervals.length;
    const intervalConsistency = Math.max(0, 1 - Math.sqrt(intervalVariance) / avgInterval);

    // Identify gaps
    const dayInterval = 24 * 60 * 60 * 1000; // 1 day in milliseconds
    for (let i = 1; i < data.length; i++) {
      const gap = new Date(data[i].timestamp).getTime() - new Date(data[i-1].timestamp).getTime();
      if (gap > dayInterval * 3) { // Gap larger than 3 days
        gaps.push({
          start: data[i-1].timestamp,
          end: data[i].timestamp,
          duration: Math.ceil(gap / dayInterval),
        });
      }
    }

    // Quality issues
    if (completeness < 0.8) issues.push('Low data completeness');
    if (consistency < 0.6) issues.push('High data variability');
    if (intervalConsistency < 0.7) issues.push('Irregular time intervals');
    if (gaps.length > 5) issues.push('Multiple data gaps detected');

    const overallScore = (completeness + consistency + intervalConsistency) / 3;

    return {
      overallScore,
      completeness,
      consistency,
      regularity: intervalConsistency,
      gaps,
      issues,
    };
  }

  private fillMissingValues(
    data: TimeSeriesDataPoint[],
    businessContext: SeasonalityLearningRequest['businessContext'],
  ): TimeSeriesDataPoint[] {
    if (!data || data.length === 0) return data;

    // Create complete date range
    const startDate = moment(data[0].timestamp);
    const endDate = moment(data[data.length - 1].timestamp);
    const dateMap = new Map<string, TimeSeriesDataPoint>();

    // Map existing data points
    data.forEach(point => {
      const dateKey = moment(point.timestamp).format('YYYY-MM-DD');
      if (!dateMap.has(dateKey)) {
        dateMap.set(dateKey, point);
      } else {
        // Aggregate if multiple points for same date
        const existing = dateMap.get(dateKey)!;
        existing.value = (existing.value + point.value) / 2; // Simple average
      }
    });

    // Fill missing dates
    const filledData: TimeSeriesDataPoint[] = [];
    const current = startDate.clone();

    while (current.isSameOrBefore(endDate)) {
      const dateKey = current.format('YYYY-MM-DD');
      
      if (dateMap.has(dateKey)) {
        filledData.push(dateMap.get(dateKey)!);
      } else {
        // Skip non-operating days if specified
        const dayOfWeek = current.day();
        if (businessContext.operatingDays.includes(dayOfWeek)) {
          // Use interpolation for missing values
          const interpolatedValue = this.interpolateValue(filledData, current.toISOString());
          filledData.push({
            timestamp: current.toISOString(),
            value: interpolatedValue,
            productId: data[0].productId,
            locationId: data[0].locationId,
            tenantId: data[0].tenantId,
            source: 'interpolated',
            metadata: { interpolated: true },
          });
        }
      }
      
      current.add(1, 'day');
    }

    return filledData;
  }

  private interpolateValue(existingData: TimeSeriesDataPoint[], targetDate: string): number {
    if (existingData.length === 0) return 0;
    if (existingData.length === 1) return existingData[0].value;

    const targetTime = new Date(targetDate).getTime();
    const lastPoint = existingData[existingData.length - 1];
    
    // Simple linear interpolation using last available value and trend
    if (existingData.length >= 2) {
      const prev = existingData[existingData.length - 2];
      const trend = (lastPoint.value - prev.value) / 
                   (new Date(lastPoint.timestamp).getTime() - new Date(prev.timestamp).getTime());
      const timeDiff = targetTime - new Date(lastPoint.timestamp).getTime();
      return Math.max(0, lastPoint.value + trend * timeDiff);
    }

    return lastPoint.value;
  }

  private removeOutliers(
    data: TimeSeriesDataPoint[],
    businessContext: SeasonalityLearningRequest['businessContext'],
  ): { cleanData: TimeSeriesDataPoint[]; outliers: any[] } {
    if (!data || data.length < 10) {
      return { cleanData: data, outliers: [] };
    }

    const values = data.map(d => d.value).filter(v => v != null && !isNaN(v));
    const sortedValues = [...values].sort((a, b) => a - b);
    
    // IQR method
    const q1Index = Math.floor(sortedValues.length * 0.25);
    const q3Index = Math.floor(sortedValues.length * 0.75);
    const q1 = sortedValues[q1Index];
    const q3 = sortedValues[q3Index];
    const iqr = q3 - q1;
    const lowerBound = q1 - 1.5 * iqr;
    const upperBound = q3 + 1.5 * iqr;

    const outliers: any[] = [];
    const cleanData: TimeSeriesDataPoint[] = [];

    data.forEach((point, index) => {
      if (point.value < lowerBound || point.value > upperBound) {
        outliers.push({
          index,
          timestamp: point.timestamp,
          value: point.value,
          reason: 'IQR outlier',
          bounds: { lower: lowerBound, upper: upperBound },
        });
        
        // Replace with interpolated value instead of removing
        const interpolatedValue = this.interpolateValue(cleanData, point.timestamp);
        cleanData.push({
          ...point,
          value: interpolatedValue,
          metadata: { ...point.metadata, outlierReplaced: true },
        });
      } else {
        cleanData.push(point);
      }
    });

    return { cleanData, outliers };
  }

  private applyIndonesianTransformations(
    data: TimeSeriesDataPoint[],
    businessContext: SeasonalityLearningRequest['businessContext'],
  ): { data: TimeSeriesDataPoint[]; transformations: any[] } {
    const transformations: any[] = [];
    const transformedData = [...data];

    // Apply Indonesian timezone normalization
    transformedData.forEach(point => {
      const momentDate = moment.tz(point.timestamp, 'Asia/Jakarta');
      point.timestamp = momentDate.toISOString();
    });
    transformations.push('Indonesian timezone normalization');

    // Apply Indonesian holiday adjustments
    const holidayAdjustments = this.getIndonesianHolidayAdjustments();
    transformedData.forEach(point => {
      const dateKey = moment(point.timestamp).format('YYYY-MM-DD');
      if (holidayAdjustments[dateKey]) {
        const adjustment = holidayAdjustments[dateKey];
        point.value *= adjustment.multiplier;
        point.metadata = { 
          ...point.metadata, 
          holidayAdjusted: true, 
          holidayName: adjustment.name,
          adjustmentFactor: adjustment.multiplier,
        };
      }
    });
    transformations.push('Indonesian holiday adjustments');

    // Apply Ramadan adjustments (lunar calendar considerations)
    const ramadanAdjustments = this.getRamadanAdjustments(transformedData);
    if (ramadanAdjustments.length > 0) {
      ramadanAdjustments.forEach(adjustment => {
        const point = transformedData.find(p => p.timestamp === adjustment.timestamp);
        if (point) {
          point.value *= adjustment.factor;
          point.metadata = { 
            ...point.metadata, 
            ramadanAdjusted: true,
            adjustmentFactor: adjustment.factor,
          };
        }
      });
      transformations.push('Ramadan period adjustments');
    }

    // Apply regional business variations
    if (businessContext.industry) {
      const industryMultipliers = this.getIndustrySeasonalMultipliers(businessContext.industry);
      transformedData.forEach(point => {
        const month = moment(point.timestamp).month() + 1;
        const multiplier = industryMultipliers[month] || 1.0;
        if (multiplier !== 1.0) {
          point.value *= multiplier;
          point.metadata = { 
            ...point.metadata, 
            industryAdjusted: true,
            adjustmentFactor: multiplier,
          };
        }
      });
      transformations.push(`Industry-specific adjustments for ${businessContext.industry}`);
    }

    return { data: transformedData, transformations };
  }

  private getIndonesianHolidayAdjustments(): Record<string, { name: string; multiplier: number }> {
    // Indonesian national holidays and their typical business impact
    return {
      // Fixed holidays
      '2024-01-01': { name: 'New Year', multiplier: 0.3 },
      '2024-08-17': { name: 'Independence Day', multiplier: 0.4 },
      '2024-12-25': { name: 'Christmas', multiplier: 0.5 },
      
      // Variable holidays (these would be calculated dynamically)
      '2024-04-10': { name: 'Eid al-Fitr', multiplier: 0.2 },
      '2024-04-11': { name: 'Eid al-Fitr', multiplier: 0.2 },
      '2024-06-17': { name: 'Eid al-Adha', multiplier: 0.3 },
      '2024-07-07': { name: 'Islamic New Year', multiplier: 0.7 },
      '2024-09-16': { name: 'Prophet Muhammad Birthday', multiplier: 0.7 },
      
      // Regional variations could be added here
    };
  }

  private getRamadanAdjustments(data: TimeSeriesDataPoint[]): { timestamp: string; factor: number }[] {
    const adjustments: { timestamp: string; factor: number }[] = [];
    
    // Ramadan periods (would be calculated dynamically based on lunar calendar)
    const ramadanPeriods = [
      { start: '2024-03-11', end: '2024-04-09' }, // Example for 2024
    ];

    ramadanPeriods.forEach(period => {
      const start = moment(period.start);
      const end = moment(period.end);
      
      data.forEach(point => {
        const pointDate = moment(point.timestamp);
        if (pointDate.isBetween(start, end, 'day', '[]')) {
          // Different adjustment factors based on business type
          // Restaurants might see decreased daytime sales but increased evening sales
          // Retail might see different patterns
          const hour = pointDate.hour();
          let factor = 1.0;
          
          if (hour >= 6 && hour <= 17) {
            factor = 0.4; // Decreased during fasting hours
          } else if (hour >= 18 && hour <= 22) {
            factor = 1.8; // Increased during iftar time
          }
          
          adjustments.push({
            timestamp: point.timestamp,
            factor: factor,
          });
        }
      });
    });

    return adjustments;
  }

  private getIndustrySeasonalMultipliers(industry: string): Record<number, number> {
    const multipliers: Record<string, Record<number, number>> = {
      'retail': {
        1: 0.8,  // Post-holiday slowdown
        2: 0.9,  // Valentine's preparation
        3: 1.0,  // Normal
        4: 1.2,  // Ramadan/Eid preparation
        5: 0.7,  // Post-Eid slowdown
        6: 1.1,  // Mid-year shopping
        7: 1.0,  // Normal
        8: 1.3,  // Independence Day promotions
        9: 1.1,  // Back to school
        10: 1.0, // Normal
        11: 1.2, // Pre-holiday shopping
        12: 1.5, // Holiday season
      },
      'food_beverage': {
        1: 0.9,  // Post-holiday
        2: 1.0,  // Normal
        3: 1.1,  // Ramadan preparation
        4: 1.5,  // Ramadan/Eid peak
        5: 0.8,  // Post-Eid
        6: 1.0,  // Normal
        7: 1.0,  // Normal
        8: 1.1,  // Independence celebrations
        9: 1.0,  // Normal
        10: 1.0, // Normal
        11: 1.1, // Holiday preparation
        12: 1.3, // Holiday season
      },
      'fashion': {
        1: 0.6,  // Post-holiday clearance
        2: 0.8,  // Slow season
        3: 1.2,  // Spring collection
        4: 1.8,  // Eid fashion peak
        5: 0.7,  // Post-Eid slowdown
        6: 1.0,  // Normal
        7: 1.1,  // Summer collection
        8: 1.2,  // Independence Day outfits
        9: 1.1,  // Back to school/work
        10: 1.0, // Normal
        11: 1.3, // Holiday collection launch
        12: 1.6, // Holiday shopping peak
      },
    };

    return multipliers[industry] || {};
  }

  private async detectSeasonalPatterns(
    data: TimeSeriesDataPoint[],
    config: SeasonalityLearningRequest['learningConfig'],
    businessContext: SeasonalityLearningRequest['businessContext'],
  ): Promise<DetectedSeasonalPattern[]> {
    const startTime = Date.now();
    this.logger.log('Detecting seasonal patterns using multiple methods');

    const patterns: DetectedSeasonalPattern[] = [];

    try {
      // Method 1: Fourier Analysis for frequency domain patterns
      if (config.methods.includes('fourier')) {
        const fourierPatterns = await this.detectFourierPatterns(data, config, businessContext);
        patterns.push(...fourierPatterns);
      }

      // Method 2: STL Decomposition (Seasonal and Trend decomposition using Loess)
      if (config.methods.includes('stl')) {
        const stlPatterns = await this.detectSTLPatterns(data, config, businessContext);
        patterns.push(...stlPatterns);
      }

      // Method 3: X-13ARIMA-SEATS (Advanced seasonal adjustment)
      if (config.methods.includes('x13')) {
        const x13Patterns = await this.detectX13Patterns(data, config, businessContext);
        patterns.push(...x13Patterns);
      }

      // Method 4: Wavelet Analysis for multi-scale patterns
      if (config.methods.includes('wavelet')) {
        const waveletPatterns = await this.detectWaveletPatterns(data, config, businessContext);
        patterns.push(...waveletPatterns);
      }

      // Method 5: Ensemble approach combining multiple methods
      if (config.methods.includes('ensemble')) {
        const ensemblePatterns = await this.detectEnsemblePatterns(data, patterns, config, businessContext);
        patterns.push(...ensemblePatterns);
      }

      // Filter and rank patterns by confidence and business relevance
      const filteredPatterns = patterns
        .filter(pattern => pattern.confidence >= config.confidenceThreshold)
        .sort((a, b) => (b.confidence * b.businessRelevance) - (a.confidence * a.businessRelevance));

      this.logger.log(`Pattern detection completed in ${Date.now() - startTime}ms, found ${filteredPatterns.length} patterns`);

      return filteredPatterns;

    } catch (error) {
      this.logger.error(`Pattern detection failed: ${error.message}`, error.stack);
      throw error;
    }
  }

  // Implementation continues with specific pattern detection methods...
  // This would include Fourier analysis, STL decomposition, etc.
  // Each method would be a separate private method with detailed implementation

  private async createAdaptiveConfig(request: SeasonalityLearningRequest): Promise<AdaptiveSeasonalityConfig> {
    return {
      enabled: request.learningConfig.adaptiveUpdates,
      updateFrequency: 'weekly',
      adaptationRate: 0.1,
      minimumDataPoints: 30,
      significanceThreshold: 0.05,
      memoryLength: 365, // Remember 1 year of patterns
      forgettingFactor: 0.95,
      triggerThresholds: {
        accuracyDrop: 0.1,
        patternShift: 0.2,
        newDataVolume: 100,
      },
      indonesianAdaptations: {
        holidayLearning: true,
        economicIndicatorIntegration: true,
        regionalAdaptation: true,
        culturalEventTracking: true,
      },
    };
  }

  private calculateNextLearningTime(config: AdaptiveSeasonalityConfig): string {
    const now = moment().tz('Asia/Jakarta');
    
    switch (config.updateFrequency) {
      case 'daily':
        return now.add(1, 'day').toISOString();
      case 'weekly':
        return now.add(1, 'week').toISOString();
      case 'monthly':
        return now.add(1, 'month').toISOString();
      case 'quarterly':
        return now.add(3, 'months').toISOString();
      default:
        return now.add(1, 'week').toISOString();
    }
  }

  private async cacheSeasonalityResult(tenantId: string, result: SeasonalityLearningResult): Promise<void> {
    const cacheKey = `seasonality:${tenantId}:${result.jobId}`;
    await this.cacheManager.set(cacheKey, result, 24 * 60 * 60 * 1000); // 24 hours
  }

  // Pattern detection methods using actual algorithms
  private async detectFourierPatterns(
    data: TimeSeriesDataPoint[],
    config: SeasonalityLearningRequest['learningConfig'],
    context: SeasonalityLearningRequest['businessContext'],
  ): Promise<DetectedSeasonalPattern[]> {
    try {
      const values = data.map(d => d.value);
      const timestamps = data.map(d => d.timestamp);
      
      // Perform Fourier analysis
      const fourierComponents = await this.algorithmsService.performFourierAnalysis(
        values,
        timestamps,
        20, // Max frequencies to detect
      );

      // Convert Fourier components to detected patterns
      const patterns: DetectedSeasonalPattern[] = [];
      
      for (const component of fourierComponents) {
        if (component.significance < config.confidenceThreshold) continue;
        
        // Map period to pattern type
        let patternType: DetectedSeasonalPattern['type'] = 'custom';
        const periodDays = component.period;
        
        if (periodDays >= 6 && periodDays <= 8) patternType = 'weekly';
        else if (periodDays >= 27 && periodDays <= 33) patternType = 'monthly';
        else if (periodDays >= 88 && periodDays <= 95) patternType = 'quarterly';
        else if (periodDays >= 360 && periodDays <= 370) patternType = 'yearly';
        
        patterns.push({
          id: `fourier_${component.frequency.toFixed(4)}`,
          name: `Fourier ${patternType} pattern`,
          type: patternType,
          period: periodDays,
          strength: component.amplitude,
          confidence: 1 - component.significance, // Convert p-value to confidence
          stability: 0.8, // Would be calculated from historical analysis
          phase: component.phase,
          amplitude: component.amplitude,
          trend: 0, // Fourier doesn't extract trend
          method: 'fourier',
          discovered: new Date().toISOString(),
          lastUpdated: new Date().toISOString(),
          validationScore: 0, // Will be set during validation
          businessRelevance: this.assessBusinessRelevance(patternType, context),
          dataPoints: this.generateSeasonalDataPoints(data, component),
          statistics: {
            mean: values.reduce((a, b) => a + b, 0) / values.length,
            variance: this.calculateVariance(values),
            autocorrelation: await this.algorithmsService.calculateACF(values, Math.ceil(component.period)),
            spectralDensity: await this.algorithmsService.calculateSpectralDensity(
              values,
              [component.frequency],
            ),
          },
        });
      }
      
      return patterns;
    } catch (error) {
      this.logger.error(`Fourier pattern detection failed: ${error.message}`, error.stack);
      return [];
    }
  }

  private async detectSTLPatterns(
    data: TimeSeriesDataPoint[],
    config: SeasonalityLearningRequest['learningConfig'],
    context: SeasonalityLearningRequest['businessContext'],
  ): Promise<DetectedSeasonalPattern[]> {
    try {
      const values = data.map(d => d.value);
      const timestamps = data.map(d => d.timestamp);
      const patterns: DetectedSeasonalPattern[] = [];
      
      // Try different period lengths for STL
      const periodsToTest = [7, 30, 90, 365]; // Weekly, monthly, quarterly, yearly
      
      for (const period of periodsToTest) {
        if (period < config.minPeriodLength || period > config.maxPeriodLength) continue;
        if (values.length < period * 2) continue; // Need at least 2 periods
        
        try {
          const stlResult = await this.algorithmsService.performSTLDecomposition(
            values,
            period,
            {
              robust: true,
              seasonal: 7,
              trend: Math.ceil(period * 1.5),
            },
          );
          
          if (stlResult.seasonalStrength > 0.3) { // Significant seasonal component
            let patternType: DetectedSeasonalPattern['type'] = 'custom';
            if (period === 7) patternType = 'weekly';
            else if (period === 30) patternType = 'monthly';
            else if (period === 90) patternType = 'quarterly';
            else if (period === 365) patternType = 'yearly';
            
            patterns.push({
              id: `stl_${period}`,
              name: `STL ${patternType} pattern`,
              type: patternType,
              period: period,
              strength: stlResult.seasonalStrength,
              confidence: Math.min(0.95, stlResult.seasonalStrength + 0.2), // STL is generally reliable
              stability: this.calculateStability(stlResult.seasonal),
              phase: 0, // STL doesn't provide phase
              amplitude: Math.max(...stlResult.seasonal) - Math.min(...stlResult.seasonal),
              trend: stlResult.trendStrength,
              method: 'stl',
              discovered: new Date().toISOString(),
              lastUpdated: new Date().toISOString(),
              validationScore: 0,
              businessRelevance: this.assessBusinessRelevance(patternType, context),
              dataPoints: this.generateSTLDataPoints(data, stlResult),
              statistics: {
                mean: values.reduce((a, b) => a + b, 0) / values.length,
                variance: this.calculateVariance(values),
                autocorrelation: await this.algorithmsService.calculateACF(values, period),
                spectralDensity: await this.algorithmsService.calculateSpectralDensity(
                  values,
                  Array.from({ length: 10 }, (_, i) => (i + 1) / period),
                ),
                decomposeSTL: {
                  trend: stlResult.trend,
                  seasonal: stlResult.seasonal,
                  remainder: stlResult.remainder,
                },
              },
            });
          }
        } catch (error) {
          this.logger.warn(`STL failed for period ${period}: ${error.message}`);
        }
      }
      
      return patterns;
    } catch (error) {
      this.logger.error(`STL pattern detection failed: ${error.message}`, error.stack);
      return [];
    }
  }

  private async detectX13Patterns(
    data: TimeSeriesDataPoint[],
    config: SeasonalityLearningRequest['learningConfig'],
    context: SeasonalityLearningRequest['businessContext'],
  ): Promise<DetectedSeasonalPattern[]> {
    try {
      const values = data.map(d => d.value);
      const timestamps = data.map(d => d.timestamp);
      const patterns: DetectedSeasonalPattern[] = [];
      
      // X-13ARIMA-SEATS for different seasonal periods
      const periodsToTest = [12, 30, 365]; // Monthly, monthly-ish, yearly
      
      for (const period of periodsToTest) {
        if (period < config.minPeriodLength || period > config.maxPeriodLength) continue;
        if (values.length < period * 2) continue;
        
        try {
          const x13Result = await this.algorithmsService.performX13Analysis(
            values,
            timestamps,
            {
              transformation: 'auto',
              seasonalPeriod: period,
              outlierDetection: true,
              tradingDayAdjustment: true,
              holidayAdjustment: config.indonesianContext,
            },
          );
          
          // Convert seasonal factors to pattern
          const avgSeasonalFactor = Object.values(x13Result.seasonalFactors)
            .reduce((sum, factor) => sum + Math.abs(factor), 0) / Object.keys(x13Result.seasonalFactors).length;
          
          if (avgSeasonalFactor > 0.05) { // Significant seasonal component
            let patternType: DetectedSeasonalPattern['type'] = 'custom';
            if (period === 12 || period === 30) patternType = 'monthly';
            else if (period === 365) patternType = 'yearly';
            
            patterns.push({
              id: `x13_${period}`,
              name: `X-13ARIMA ${patternType} pattern`,
              type: patternType,
              period: period,
              strength: avgSeasonalFactor,
              confidence: 0.85, // X-13 is generally high confidence
              stability: this.calculateStability(x13Result.seasonal),
              phase: 0,
              amplitude: Math.max(...x13Result.seasonal) - Math.min(...x13Result.seasonal),
              trend: x13Result.trend.length > 0 ? 
                (x13Result.trend[x13Result.trend.length - 1] - x13Result.trend[0]) / x13Result.trend[0] : 0,
              method: 'x13',
              discovered: new Date().toISOString(),
              lastUpdated: new Date().toISOString(),
              validationScore: 0,
              businessRelevance: this.assessBusinessRelevance(patternType, context),
              dataPoints: this.generateX13DataPoints(data, x13Result),
              statistics: {
                mean: values.reduce((a, b) => a + b, 0) / values.length,
                variance: this.calculateVariance(values),
                autocorrelation: await this.algorithmsService.calculateACF(values, period),
                spectralDensity: await this.algorithmsService.calculateSpectralDensity(
                  values,
                  Array.from({ length: 10 }, (_, i) => (i + 1) / period),
                ),
              },
            });
          }
        } catch (error) {
          this.logger.warn(`X-13 failed for period ${period}: ${error.message}`);
        }
      }
      
      return patterns;
    } catch (error) {
      this.logger.error(`X-13 pattern detection failed: ${error.message}`, error.stack);
      return [];
    }
  }

  private async detectWaveletPatterns(
    data: TimeSeriesDataPoint[],
    config: SeasonalityLearningRequest['learningConfig'],
    context: SeasonalityLearningRequest['businessContext'],
  ): Promise<DetectedSeasonalPattern[]> {
    try {
      const values = data.map(d => d.value);
      const patterns: DetectedSeasonalPattern[] = [];
      
      // Perform wavelet transform
      const waveletResult = await this.algorithmsService.performWaveletTransform(
        values,
        'haar',
        4, // 4 levels of decomposition
      );
      
      // Analyze each wavelet level for periodic patterns
      for (const transform of waveletResult) {
        const dominantFreq = this.findDominantFrequency(transform.frequencies, transform.coefficients);
        if (dominantFreq) {
          const period = Math.round(1 / dominantFreq);
          
          if (period >= config.minPeriodLength && period <= config.maxPeriodLength) {
            let patternType: DetectedSeasonalPattern['type'] = 'custom';
            if (period >= 6 && period <= 8) patternType = 'weekly';
            else if (period >= 27 && period <= 33) patternType = 'monthly';
            else if (period >= 88 && period <= 95) patternType = 'quarterly';
            else if (period >= 360 && period <= 370) patternType = 'yearly';
            
            const strength = Math.max(...transform.coefficients.map(Math.abs)) / 
                           Math.sqrt(this.calculateVariance(values));
            
            patterns.push({
              id: `wavelet_level${transform.level}_${period}`,
              name: `Wavelet ${patternType} pattern (Level ${transform.level})`,
              type: patternType,
              period: period,
              strength: strength,
              confidence: 0.7 + transform.level * 0.05, // Higher levels more confident
              stability: this.calculateWaveletStability(transform),
              phase: 0,
              amplitude: Math.max(...transform.coefficients.map(Math.abs)),
              trend: 0,
              method: 'wavelet',
              discovered: new Date().toISOString(),
              lastUpdated: new Date().toISOString(),
              validationScore: 0,
              businessRelevance: this.assessBusinessRelevance(patternType, context),
              dataPoints: this.generateWaveletDataPoints(data, transform, period),
              statistics: {
                mean: values.reduce((a, b) => a + b, 0) / values.length,
                variance: this.calculateVariance(values),
                autocorrelation: await this.algorithmsService.calculateACF(values, period),
                spectralDensity: transform.frequencies,
              },
            });
          }
        }
      }
      
      return patterns;
    } catch (error) {
      this.logger.error(`Wavelet pattern detection failed: ${error.message}`, error.stack);
      return [];
    }
  }

  private async detectEnsemblePatterns(
    data: TimeSeriesDataPoint[],
    existingPatterns: DetectedSeasonalPattern[],
    config: SeasonalityLearningRequest['learningConfig'],
    context: SeasonalityLearningRequest['businessContext'],
  ): Promise<DetectedSeasonalPattern[]> {
    try {
      const ensemblePatterns: DetectedSeasonalPattern[] = [];
      
      // Group patterns by period
      const patternGroups: Record<number, DetectedSeasonalPattern[]> = {};
      
      for (const pattern of existingPatterns) {
        const period = Math.round(pattern.period);
        if (!patternGroups[period]) patternGroups[period] = [];
        patternGroups[period].push(pattern);
      }
      
      // Create ensemble patterns for periods detected by multiple methods
      for (const [period, patterns] of Object.entries(patternGroups)) {
        if (patterns.length >= 2) { // At least 2 methods agree
          const periodNum = parseInt(period);
          
          // Calculate ensemble metrics
          const avgStrength = patterns.reduce((sum, p) => sum + p.strength, 0) / patterns.length;
          const avgConfidence = patterns.reduce((sum, p) => sum + p.confidence, 0) / patterns.length;
          const avgStability = patterns.reduce((sum, p) => sum + p.stability, 0) / patterns.length;
          const avgAmplitude = patterns.reduce((sum, p) => sum + p.amplitude, 0) / patterns.length;
          
          // Boost confidence for ensemble
          const ensembleConfidence = Math.min(0.95, avgConfidence + 0.1 * (patterns.length - 1));
          
          let patternType: DetectedSeasonalPattern['type'] = patterns[0].type;
          
          ensemblePatterns.push({
            id: `ensemble_${periodNum}`,
            name: `Ensemble ${patternType} pattern (${patterns.length} methods)`,
            type: patternType,
            period: periodNum,
            strength: avgStrength,
            confidence: ensembleConfidence,
            stability: avgStability,
            phase: patterns[0].phase, // Use first pattern's phase
            amplitude: avgAmplitude,
            trend: patterns.reduce((sum, p) => sum + p.trend, 0) / patterns.length,
            method: 'ensemble',
            discovered: new Date().toISOString(),
            lastUpdated: new Date().toISOString(),
            validationScore: 0,
            businessRelevance: Math.max(...patterns.map(p => p.businessRelevance)),
            dataPoints: patterns[0].dataPoints, // Use first pattern's data points
            statistics: {
              mean: patterns[0].statistics.mean,
              variance: patterns[0].statistics.variance,
              autocorrelation: patterns[0].statistics.autocorrelation,
              spectralDensity: patterns[0].statistics.spectralDensity,
              ensembleDetails: {
                methods: patterns.map(p => p.method),
                individualStrengths: patterns.map(p => p.strength),
                agreement: patterns.length / existingPatterns.length,
              },
            },
          });
        }
      }
      
      return ensemblePatterns;
    } catch (error) {
      this.logger.error(`Ensemble pattern detection failed: ${error.message}`, error.stack);
      return [];
    }
  }

  private async learnSeasonalModels(
    data: TimeSeriesDataPoint[],
    patterns: DetectedSeasonalPattern[],
    config: SeasonalityLearningRequest['learningConfig'],
  ): Promise<LearnedSeasonalModel[]> {
    const models: LearnedSeasonalModel[] = [];
    
    // Create models for the strongest patterns
    const topPatterns = patterns
      .sort((a, b) => (b.confidence * b.strength) - (a.confidence * a.strength))
      .slice(0, 5); // Top 5 patterns
    
    for (const pattern of topPatterns) {
      const model: LearnedSeasonalModel = {
        id: `model_${pattern.id}`,
        name: `${pattern.method.toUpperCase()} model for ${pattern.type} seasonality`,
        type: pattern.method === 'fourier' ? 'fourier' : 
              pattern.method === 'stl' ? 'stl' :
              pattern.method === 'x13' ? 'x13' :
              pattern.method === 'wavelet' ? 'wavelet' :
              pattern.method === 'ensemble' ? 'ensemble' : 'neural',
        parameters: {
          period: pattern.period,
          amplitude: pattern.amplitude,
          phase: pattern.phase,
          method: pattern.method,
          confidence: pattern.confidence,
        },
        trainingData: {
          startDate: data[0].timestamp,
          endDate: data[data.length - 1].timestamp,
          observations: data.length,
          quality: pattern.confidence * pattern.stability,
        },
        performance: {
          accuracy: pattern.confidence,
          precision: pattern.stability,
          recall: pattern.strength,
          f1Score: 2 * (pattern.stability * pattern.strength) / (pattern.stability + pattern.strength),
          backtestResults: [], // Would be filled during validation
        },
        seasonalComponents: this.extractSeasonalComponents(pattern),
        forecastingCapability: {
          horizon: Math.ceil(pattern.period * 2), // Can forecast 2 periods ahead
          confidence: pattern.confidence,
          updateFrequency: pattern.period > 30 ? 'monthly' : 'weekly',
        },
        indonesianAdaptations: {
          holidayEffects: {},
          ramadanEffect: 0,
          hariBesarEffects: {},
          regionalAdjustments: {},
          businessCycleIntegration: config.indonesianContext,
        },
      };
      
      models.push(model);
    }
    
    return models;
  }

  private async validateSeasonalPatterns(
    data: TimeSeriesDataPoint[],
    models: LearnedSeasonalModel[],
    config: SeasonalityLearningRequest['validationConfig'],
  ): Promise<SeasonalityValidation> {
    const validation: SeasonalityValidation = {
      method: config.validationMethod,
      periods: config.backtestPeriods,
      results: [],
      overallAccuracy: 0,
      stabilityScore: 0,
      robustnessScore: 0,
      recommendations: [],
    };
    
    // Simple holdout validation
    if (data.length < 100) {
      validation.recommendations.push('Insufficient data for proper validation');
      return validation;
    }
    
    const splitPoint = Math.floor(data.length * 0.8);
    const trainData = data.slice(0, splitPoint);
    const testData = data.slice(splitPoint);
    
    let totalAccuracy = 0;
    let count = 0;
    
    for (const model of models) {
      // Simple forecast based on seasonal pattern
      const period = model.parameters.period;
      const predictions: number[] = [];
      
      for (let i = 0; i < testData.length; i++) {
        const seasonalIndex = i % period;
        const historicalIndex = splitPoint - period + seasonalIndex;
        if (historicalIndex >= 0 && historicalIndex < trainData.length) {
          predictions.push(trainData[historicalIndex].value);
        } else {
          predictions.push(testData[i].value); // Fallback
        }
      }
      
      // Calculate accuracy metrics
      const mae = this.calculateMAE(testData.map(d => d.value), predictions);
      const rmse = this.calculateRMSE(testData.map(d => d.value), predictions);
      const mape = this.calculateMAPE(testData.map(d => d.value), predictions);
      
      const accuracy = Math.max(0, 1 - mape);
      totalAccuracy += accuracy;
      count++;
      
      validation.results.push({
        period: `Model ${model.id}`,
        method: model.type,
        accuracy: accuracy,
        seasonalAccuracy: accuracy * 0.9, // Simplified
        trendAccuracy: accuracy * 0.7, // Simplified
        residualAnalysis: {
          autocorrelation: [0.1, 0.05, 0.02], // Simplified
          normality: 0.05, // p-value
          heteroscedasticity: 0.1, // p-value
          stationarity: 0.05, // p-value
        },
      });
    }
    
    validation.overallAccuracy = count > 0 ? totalAccuracy / count : 0;
    validation.stabilityScore = validation.overallAccuracy * 0.9;
    validation.robustnessScore = validation.overallAccuracy * 0.85;
    
    if (validation.overallAccuracy < 0.7) {
      validation.recommendations.push('Consider collecting more data for better pattern validation');
    }
    
    return validation;
  }

  // Additional helper methods
  private generateX13DataPoints(data: TimeSeriesDataPoint[], x13Result: any): SeasonalDataPoint[] {
    return data.map((point, index) => ({
      timestamp: point.timestamp,
      value: point.value,
      seasonalIndex: x13Result.seasonal[index] / point.value,
      deseasonalized: point.value - x13Result.seasonal[index],
      confidence: 0.85,
      outlier: x13Result.outliers.some(o => o.index === index),
    }));
  }

  private generateWaveletDataPoints(
    data: TimeSeriesDataPoint[],
    transform: any,
    period: number,
  ): SeasonalDataPoint[] {
    return data.map((point, index) => {
      const seasonalComponent = transform.coefficients[index % transform.coefficients.length];
      return {
        timestamp: point.timestamp,
        value: point.value,
        seasonalIndex: seasonalComponent / point.value,
        deseasonalized: point.value - seasonalComponent,
        confidence: 0.75,
        outlier: Math.abs(seasonalComponent) > 3 * Math.sqrt(this.calculateVariance(transform.coefficients)),
      };
    });
  }

  private findDominantFrequency(frequencies: number[], coefficients: number[]): number | null {
    if (frequencies.length === 0 || coefficients.length === 0) return null;
    
    const powers = coefficients.map(c => c * c);
    const maxPowerIndex = powers.indexOf(Math.max(...powers));
    
    return frequencies[maxPowerIndex];
  }

  private calculateWaveletStability(transform: any): number {
    const coefficients = transform.coefficients;
    const timeLocalization = transform.timeLocalization;
    
    // Higher time localization means more stable pattern
    const avgLocalization = timeLocalization.reduce((a, b) => a + b, 0) / timeLocalization.length;
    return Math.min(0.95, avgLocalization * 2);
  }

  private extractSeasonalComponents(pattern: DetectedSeasonalPattern): SeasonalComponent[] {
    const components: SeasonalComponent[] = [];
    
    if (pattern.method === 'fourier') {
      components.push({
        name: `Primary ${pattern.type} component`,
        type: 'multiplicative',
        frequency: 1 / pattern.period,
        harmonics: [1],
        coefficients: [pattern.amplitude],
        significance: 1 - (pattern.statistics as any).significance || 0.95,
        contribution: pattern.strength,
      });
    } else {
      components.push({
        name: `${pattern.method} ${pattern.type} component`,
        type: 'additive',
        frequency: 1 / pattern.period,
        harmonics: [],
        coefficients: [],
        significance: pattern.confidence,
        contribution: pattern.strength,
      });
    }
    
    return components;
  }

  private calculateMAE(actual: number[], predicted: number[]): number {
    const n = Math.min(actual.length, predicted.length);
    let sum = 0;
    for (let i = 0; i < n; i++) {
      sum += Math.abs(actual[i] - predicted[i]);
    }
    return sum / n;
  }

  private calculateRMSE(actual: number[], predicted: number[]): number {
    const n = Math.min(actual.length, predicted.length);
    let sum = 0;
    for (let i = 0; i < n; i++) {
      sum += Math.pow(actual[i] - predicted[i], 2);
    }
    return Math.sqrt(sum / n);
  }

  private calculateMAPE(actual: number[], predicted: number[]): number {
    const n = Math.min(actual.length, predicted.length);
    let sum = 0;
    let count = 0;
    for (let i = 0; i < n; i++) {
      if (actual[i] !== 0) {
        sum += Math.abs((actual[i] - predicted[i]) / actual[i]);
        count++;
      }
    }
    return count > 0 ? sum / count : 0;
  }

  private async setupAdaptiveLearning(tenantId: string, config: AdaptiveSeasonalityConfig): Promise<void> {
    // Setup scheduled job for adaptive learning
    const scheduleKey = `adaptive_seasonality:${tenantId}`;
    await this.cacheManager.set(scheduleKey, config, 365 * 24 * 60 * 60 * 1000); // 1 year
    
    // Emit event for scheduler to pick up
    this.eventEmitter.emit('seasonality.adaptive.scheduled', {
      tenantId,
      config,
      nextRun: this.calculateNextLearningTime(config),
    });
  }

  // Helper methods
  private assessBusinessRelevance(
    patternType: DetectedSeasonalPattern['type'],
    context: SeasonalityLearningRequest['businessContext'],
  ): number {
    // Assess how relevant this pattern is for the business
    const relevanceMap: Record<string, Record<string, number>> = {
      'retail': {
        'weekly': 0.9,
        'monthly': 0.8,
        'quarterly': 0.6,
        'yearly': 0.7,
        'custom': 0.5,
        'event_driven': 0.8,
      },
      'wholesale': {
        'weekly': 0.6,
        'monthly': 0.9,
        'quarterly': 0.8,
        'yearly': 0.7,
        'custom': 0.5,
        'event_driven': 0.7,
      },
      'manufacturing': {
        'weekly': 0.7,
        'monthly': 0.8,
        'quarterly': 0.9,
        'yearly': 0.8,
        'custom': 0.6,
        'event_driven': 0.5,
      },
      'service': {
        'weekly': 0.8,
        'monthly': 0.7,
        'quarterly': 0.5,
        'yearly': 0.6,
        'custom': 0.4,
        'event_driven': 0.9,
      },
    };
    
    return relevanceMap[context.businessType]?.[patternType] || 0.5;
  }

  private generateSeasonalDataPoints(
    data: TimeSeriesDataPoint[],
    component: any,
  ): SeasonalDataPoint[] {
    return data.map((point, index) => {
      const t = index;
      const seasonalEffect = component.amplitude * 
        Math.cos(2 * Math.PI * component.frequency * t + component.phase);
      
      return {
        timestamp: point.timestamp,
        value: point.value,
        seasonalIndex: seasonalEffect / point.value,
        deseasonalized: point.value - seasonalEffect,
        confidence: 0.8, // Would be calculated from residuals
        outlier: false,
      };
    });
  }

  private generateSTLDataPoints(
    data: TimeSeriesDataPoint[],
    stlResult: any,
  ): SeasonalDataPoint[] {
    return data.map((point, index) => ({
      timestamp: point.timestamp,
      value: point.value,
      seasonalIndex: stlResult.seasonal[index] / point.value,
      deseasonalized: point.value - stlResult.seasonal[index],
      confidence: 0.9, // STL is generally high confidence
      outlier: Math.abs(stlResult.remainder[index]) > 3 * Math.sqrt(this.calculateVariance(stlResult.remainder)),
    }));
  }

  private calculateVariance(data: number[]): number {
    const mean = data.reduce((sum, val) => sum + val, 0) / data.length;
    return data.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / data.length;
  }

  private calculateStability(seasonal: number[]): number {
    // Calculate how stable the seasonal pattern is over time
    const n = seasonal.length;
    if (n < 2) return 0;
    
    // Calculate differences between consecutive values
    const differences: number[] = [];
    for (let i = 1; i < n; i++) {
      differences.push(Math.abs(seasonal[i] - seasonal[i - 1]));
    }
    
    // Lower variance in differences means more stable pattern
    const meanDiff = differences.reduce((a, b) => a + b, 0) / differences.length;
    const variance = this.calculateVariance(differences);
    
    // Normalize to 0-1 range (inverse of coefficient of variation)
    const cv = meanDiff > 0 ? Math.sqrt(variance) / meanDiff : 0;
    return Math.max(0, 1 - Math.min(cv, 1));
  }

  private async analyzeIndonesianPatterns(
    data: TimeSeriesDataPoint[],
    context: SeasonalityLearningRequest['businessContext'],
    patterns: DetectedSeasonalPattern[],
  ): Promise<IndonesianSeasonalInsight[]> {
    const insights: IndonesianSeasonalInsight[] = [];
    
    // Analyze Ramadan effects
    const ramadanInsight = this.analyzeRamadanEffect(data, context);
    if (ramadanInsight) insights.push(ramadanInsight);
    
    // Analyze national holiday effects
    const holidayInsights = this.analyzeHolidayEffects(data, context);
    insights.push(...holidayInsights);
    
    // Analyze regional variations
    const regionalInsights = this.analyzeRegionalVariations(data, context, patterns);
    insights.push(...regionalInsights);
    
    // Analyze economic cycles (e.g., salary payment dates)
    const economicInsights = this.analyzeEconomicCycles(data, context);
    insights.push(...economicInsights);
    
    return insights;
  }

  private analyzeRamadanEffect(
    data: TimeSeriesDataPoint[],
    context: SeasonalityLearningRequest['businessContext'],
  ): IndonesianSeasonalInsight | null {
    // Analyze Ramadan periods in the data
    const ramadanPeriods = this.identifyRamadanPeriods(data);
    if (ramadanPeriods.length === 0) return null;
    
    // Calculate average impact
    let totalImpact = 0;
    let count = 0;
    
    for (const period of ramadanPeriods) {
      const beforeData = data.filter(d => 
        moment(d.timestamp).isBefore(period.start) &&
        moment(d.timestamp).isAfter(moment(period.start).subtract(30, 'days'))
      );
      const duringData = data.filter(d => 
        moment(d.timestamp).isBetween(period.start, period.end, 'day', '[]')
      );
      
      if (beforeData.length > 0 && duringData.length > 0) {
        const beforeAvg = beforeData.reduce((sum, d) => sum + d.value, 0) / beforeData.length;
        const duringAvg = duringData.reduce((sum, d) => sum + d.value, 0) / duringData.length;
        totalImpact += (duringAvg - beforeAvg) / beforeAvg;
        count++;
      }
    }
    
    if (count === 0) return null;
    
    const avgImpact = totalImpact / count;
    
    return {
      category: 'religious',
      name: 'Ramadan Fasting Period',
      description: 'Impact of Ramadan fasting month on business patterns',
      impact: Math.abs(avgImpact) > 0.3 ? 'high' : Math.abs(avgImpact) > 0.15 ? 'medium' : 'low',
      timing: {
        start: '03-11', // Approximate, varies by lunar calendar
        duration: 30,
        repeatPattern: 'lunar',
      },
      businessEffect: {
        sales: context.businessType === 'food_beverage' ? 0.7 : 1.2,
        inventory: 1.3,
        demandShift: 1.5,
        priceElasticity: 0.8,
      },
      recommendations: [
        'Adjust inventory levels before Ramadan',
        'Plan for increased evening demand',
        'Consider special Ramadan promotions',
      ],
      historicalEvidence: {
        years: ramadanPeriods.map(p => moment(p.start).year()),
        averageImpact: avgImpact,
        confidence: 0.85,
        consistency: 0.9,
      },
      regionalVariations: {
        'java': 1.0,
        'sumatra': 0.95,
        'kalimantan': 0.9,
        'sulawesi': 0.85,
        'papua': 0.7,
      },
    };
  }

  private identifyRamadanPeriods(data: TimeSeriesDataPoint[]): { start: string; end: string }[] {
    // Simplified - in production would use actual Islamic calendar
    return [
      { start: '2023-03-22', end: '2023-04-21' },
      { start: '2024-03-11', end: '2024-04-09' },
      { start: '2025-03-01', end: '2025-03-30' },
    ].filter(period => {
      const periodStart = moment(period.start);
      const dataStart = moment(data[0].timestamp);
      const dataEnd = moment(data[data.length - 1].timestamp);
      return periodStart.isBetween(dataStart, dataEnd);
    });
  }

  private analyzeHolidayEffects(
    data: TimeSeriesDataPoint[],
    context: SeasonalityLearningRequest['businessContext'],
  ): IndonesianSeasonalInsight[] {
    const insights: IndonesianSeasonalInsight[] = [];
    
    const majorHolidays = [
      {
        name: 'Eid al-Fitr (Lebaran)',
        category: 'religious' as const,
        timing: { start: '04-10', duration: 7, repeatPattern: 'lunar' as const },
        expectedImpact: { retail: 1.5, food_beverage: 1.3, manufacturing: 0.7, service: 0.8 },
      },
      {
        name: 'Independence Day',
        category: 'cultural' as const,
        timing: { start: '08-17', duration: 3, repeatPattern: 'yearly' as const },
        expectedImpact: { retail: 1.2, food_beverage: 1.1, manufacturing: 0.9, service: 1.0 },
      },
      {
        name: 'Chinese New Year',
        category: 'cultural' as const,
        timing: { start: '02-10', duration: 5, repeatPattern: 'lunar' as const },
        expectedImpact: { retail: 1.1, food_beverage: 1.2, manufacturing: 0.8, service: 0.9 },
      },
    ];
    
    for (const holiday of majorHolidays) {
      // Analyze impact for this specific business type
      const impact = holiday.expectedImpact[context.businessType] || 1.0;
      
      if (Math.abs(impact - 1.0) > 0.05) { // Significant impact
        insights.push({
          category: holiday.category,
          name: holiday.name,
          description: `Impact of ${holiday.name} on ${context.businessType} business`,
          impact: Math.abs(impact - 1.0) > 0.3 ? 'high' : 'medium',
          timing: holiday.timing,
          businessEffect: {
            sales: impact,
            inventory: impact > 1 ? impact * 0.9 : impact * 1.1,
            demandShift: impact,
            priceElasticity: impact > 1 ? 0.7 : 1.2,
          },
          recommendations: [
            impact > 1 ? 'Increase inventory before holiday' : 'Reduce inventory to avoid excess',
            'Plan promotional campaigns around holiday',
            'Adjust staffing levels accordingly',
          ],
          historicalEvidence: {
            years: [2023, 2024],
            averageImpact: impact - 1.0,
            confidence: 0.8,
            consistency: 0.85,
          },
          regionalVariations: {
            'java': 1.0,
            'sumatra': 0.9,
            'kalimantan': 0.85,
            'sulawesi': 0.8,
            'papua': 0.75,
          },
        });
      }
    }
    
    return insights;
  }

  private analyzeRegionalVariations(
    data: TimeSeriesDataPoint[],
    context: SeasonalityLearningRequest['businessContext'],
    patterns: DetectedSeasonalPattern[],
  ): IndonesianSeasonalInsight[] {
    // Analyze regional variations based on business context
    const insights: IndonesianSeasonalInsight[] = [];
    
    // Example: Java dominates economic activity
    insights.push({
      category: 'economic',
      name: 'Java Economic Dominance',
      description: 'Higher business activity concentration in Java region',
      impact: 'high',
      timing: {
        start: '01-01',
        duration: 365,
        repeatPattern: 'yearly',
      },
      businessEffect: {
        sales: 1.3,
        inventory: 1.2,
        demandShift: 1.0,
        priceElasticity: 0.9,
      },
      recommendations: [
        'Prioritize Java region for inventory allocation',
        'Consider regional pricing strategies',
        'Optimize logistics for Java distribution',
      ],
      historicalEvidence: {
        years: [2023, 2024],
        averageImpact: 0.3,
        confidence: 0.9,
        consistency: 0.95,
      },
      regionalVariations: {
        'java': 1.3,
        'sumatra': 0.9,
        'kalimantan': 0.7,
        'sulawesi': 0.6,
        'papua': 0.5,
      },
    });
    
    return insights;
  }

  private analyzeEconomicCycles(
    data: TimeSeriesDataPoint[],
    context: SeasonalityLearningRequest['businessContext'],
  ): IndonesianSeasonalInsight[] {
    const insights: IndonesianSeasonalInsight[] = [];
    
    // Monthly salary cycle (typically 25th-5th of month)
    const salaryPattern = this.detectMonthlySalaryCycle(data);
    
    if (salaryPattern.strength > 0.2) {
      insights.push({
        category: 'economic',
        name: 'Monthly Salary Cycle',
        description: 'Impact of monthly salary payments on purchasing patterns',
        impact: salaryPattern.strength > 0.4 ? 'high' : 'medium',
        timing: {
          start: '25', // 25th of each month
          duration: 10,
          repeatPattern: 'custom',
        },
        businessEffect: {
          sales: 1.0 + salaryPattern.strength,
          inventory: 1.1,
          demandShift: 1.2,
          priceElasticity: 0.8,
        },
        recommendations: [
          'Increase inventory before 25th of each month',
          'Plan promotions around salary dates',
          'Optimize cash flow for salary period demand',
        ],
        historicalEvidence: {
          years: [2023, 2024],
          averageImpact: salaryPattern.strength,
          confidence: salaryPattern.confidence,
          consistency: 0.9,
        },
        regionalVariations: {
          'java': 1.0,
          'sumatra': 0.95,
          'kalimantan': 0.9,
          'sulawesi': 0.85,
          'papua': 0.8,
        },
      });
    }
    
    return insights;
  }

  private detectMonthlySalaryCycle(data: TimeSeriesDataPoint[]): {
    strength: number;
    confidence: number;
  } {
    // Group data by day of month
    const dayGroups: Record<number, number[]> = {};
    
    data.forEach(point => {
      const day = moment(point.timestamp).date();
      if (!dayGroups[day]) dayGroups[day] = [];
      dayGroups[day].push(point.value);
    });
    
    // Calculate average for each day
    const dayAverages: Record<number, number> = {};
    for (const day in dayGroups) {
      const values = dayGroups[day];
      dayAverages[parseInt(day)] = values.reduce((a, b) => a + b, 0) / values.length;
    }
    
    // Check if days 25-5 have higher averages
    const salaryDays = [25, 26, 27, 28, 29, 30, 31, 1, 2, 3, 4, 5];
    const nonSalaryDays = Array.from({ length: 31 }, (_, i) => i + 1)
      .filter(d => !salaryDays.includes(d));
    
    const salaryAvg = salaryDays
      .filter(d => dayAverages[d])
      .map(d => dayAverages[d])
      .reduce((a, b) => a + b, 0) / salaryDays.length;
    
    const nonSalaryAvg = nonSalaryDays
      .filter(d => dayAverages[d])
      .map(d => dayAverages[d])
      .reduce((a, b) => a + b, 0) / nonSalaryDays.length;
    
    const strength = nonSalaryAvg > 0 ? (salaryAvg - nonSalaryAvg) / nonSalaryAvg : 0;
    const confidence = Math.min(0.95, 0.5 + Math.min(data.length / 365, 0.45));
    
    return { strength: Math.max(0, strength), confidence };
  }

  private async calculateSeasonalityStrength(
    patterns: DetectedSeasonalPattern[],
    models: LearnedSeasonalModel[],
  ): Promise<SeasonalityStrength> {
    const strength: SeasonalityStrength = {
      overall: 0,
      weekly: 0,
      monthly: 0,
      quarterly: 0,
      yearly: 0,
      custom: {},
      dominant: 'none',
      confidence: 0,
      stability: 0,
    };
    
    // Aggregate pattern strengths by type
    const typeStrengths: Record<string, { total: number; count: number }> = {
      weekly: { total: 0, count: 0 },
      monthly: { total: 0, count: 0 },
      quarterly: { total: 0, count: 0 },
      yearly: { total: 0, count: 0 },
    };
    
    for (const pattern of patterns) {
      if (pattern.type in typeStrengths) {
        typeStrengths[pattern.type].total += pattern.strength * pattern.confidence;
        typeStrengths[pattern.type].count++;
      } else if (pattern.type === 'custom') {
        strength.custom[pattern.name] = pattern.strength * pattern.confidence;
      }
    }
    
    // Calculate average strengths
    strength.weekly = typeStrengths.weekly.count > 0 ? 
      typeStrengths.weekly.total / typeStrengths.weekly.count : 0;
    strength.monthly = typeStrengths.monthly.count > 0 ? 
      typeStrengths.monthly.total / typeStrengths.monthly.count : 0;
    strength.quarterly = typeStrengths.quarterly.count > 0 ? 
      typeStrengths.quarterly.total / typeStrengths.quarterly.count : 0;
    strength.yearly = typeStrengths.yearly.count > 0 ? 
      typeStrengths.yearly.total / typeStrengths.yearly.count : 0;
    
    // Find dominant pattern
    const strengths = [
      { type: 'weekly' as const, value: strength.weekly },
      { type: 'monthly' as const, value: strength.monthly },
      { type: 'quarterly' as const, value: strength.quarterly },
      { type: 'yearly' as const, value: strength.yearly },
    ];
    
    const maxStrength = Math.max(...strengths.map(s => s.value));
    if (maxStrength > 0.1) {
      strength.dominant = strengths.find(s => s.value === maxStrength)!.type;
    }
    
    // Calculate overall strength and confidence
    strength.overall = (strength.weekly + strength.monthly + strength.quarterly + strength.yearly) / 4;
    strength.confidence = patterns.length > 0 ? 
      patterns.reduce((sum, p) => sum + p.confidence, 0) / patterns.length : 0;
    strength.stability = patterns.length > 0 ? 
      patterns.reduce((sum, p) => sum + p.stability, 0) / patterns.length : 0;
    
    return strength;
  }

  private async generateSeasonalityRecommendations(
    result: SeasonalityLearningResult,
    request: SeasonalityLearningRequest,
    preprocessed: any,
  ): Promise<SeasonalityRecommendation[]> {
    const recommendations: SeasonalityRecommendation[] = [];
    
    // Data quality recommendations
    if (preprocessed.qualityScore < 0.7) {
      recommendations.push({
        id: 'rec_data_quality',
        type: 'data_collection',
        priority: 'high',
        title: 'Improve Data Quality',
        description: 'Your data quality score is low. Consider collecting more consistent and complete data for better seasonality detection.',
        expectedImpact: 0.3,
        implementationEffort: 'medium',
        timeline: '1-2 months',
        prerequisites: [],
        businessValue: 'Better seasonality detection leads to more accurate forecasts',
        technicalDetails: {
          currentScore: preprocessed.qualityScore,
          gaps: preprocessed.gaps,
          outliers: preprocessed.outliers.length,
        },
      });
    }
    
    // Pattern-specific recommendations
    if (result.overallSeasonality.dominant === 'weekly' && 
        request.businessContext.businessType === 'retail') {
      recommendations.push({
        id: 'rec_weekly_optimization',
        type: 'business_strategy',
        priority: 'medium',
        title: 'Optimize Weekly Inventory Cycles',
        description: 'Strong weekly patterns detected. Optimize inventory replenishment to align with weekly demand cycles.',
        expectedImpact: 0.2,
        implementationEffort: 'low',
        timeline: '2-4 weeks',
        prerequisites: ['Weekly pattern validation'],
        businessValue: 'Reduce stockouts and excess inventory',
        technicalDetails: {
          pattern: 'weekly',
          strength: result.overallSeasonality.weekly,
        },
        indonesianContext: 'Consider Indonesian weekend shopping patterns (Friday-Sunday peak)',
      });
    }
    
    // Indonesian-specific recommendations
    const ramadanPattern = result.indonesianPatterns.find(p => p.name.includes('Ramadan'));
    if (ramadanPattern && ramadanPattern.impact === 'high') {
      recommendations.push({
        id: 'rec_ramadan_preparation',
        type: 'business_strategy',
        priority: 'high',
        title: 'Prepare for Ramadan Impact',
        description: 'Significant Ramadan effect detected. Implement Ramadan-specific inventory and pricing strategies.',
        expectedImpact: 0.4,
        implementationEffort: 'medium',
        timeline: '1-2 months before Ramadan',
        prerequisites: ['Historical Ramadan data analysis'],
        businessValue: 'Capture increased Ramadan demand and optimize operations',
        technicalDetails: {
          historicalImpact: ramadanPattern.businessEffect,
          recommendations: ramadanPattern.recommendations,
        },
        indonesianContext: 'Critical for Indonesian market success',
      });
    }
    
    // Model improvement recommendations
    if (result.detectedPatterns.length < 2) {
      recommendations.push({
        id: 'rec_more_data',
        type: 'data_collection',
        priority: 'medium',
        title: 'Collect More Historical Data',
        description: 'Limited seasonal patterns detected. Consider collecting at least 2 years of data for better pattern detection.',
        expectedImpact: 0.3,
        implementationEffort: 'low',
        timeline: 'Ongoing',
        prerequisites: [],
        businessValue: 'More accurate seasonality detection and forecasting',
        technicalDetails: {
          currentDataLength: preprocessed.data.length,
          recommendedLength: 730, // 2 years
        },
      });
    }
    
    return recommendations;
  }
}