import { Injectable, Logger, BadRequestException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { CACHE_MANAGER } from '@nestjs/cache-manager';
import { Inject } from '@nestjs/common';
import { Cache } from 'cache-manager';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { ConfigService } from '@nestjs/config';
import * as moment from 'moment-timezone';
import axios, { AxiosResponse } from 'axios';
import * as cheerio from 'cheerio';
import * as UserAgent from 'user-agents';

import { CompetitiveProduct, MarketplaceType, CompetitiveProductStatus, DataQuality } from '../entities/competitive-product.entity';
import { CompetitivePriceHistory, PriceEventType, PriceChangeReason } from '../entities/competitive-price-history.entity';

export interface MarketplaceDataCollectionRequest {
  tenantId: string;
  marketplace: MarketplaceType;
  collectionType: 'product_details' | 'price_monitoring' | 'competitor_discovery' | 'category_analysis';
  targets: {
    productIds?: string[];
    searchQueries?: string[];
    categories?: string[];
    competitors?: string[];
    regions?: string[];
  };
  collectionConfig: {
    includeImages: boolean;
    includeReviews: boolean;
    includeVariants: boolean;
    includePriceHistory: boolean;
    maxResults: number;
    dataQualityThreshold: DataQuality;
    respectRateLimit: boolean;
    useProxies: boolean;
    retryFailures: boolean;
  };
  schedulingConfig?: {
    frequency: 'realtime' | 'hourly' | 'daily' | 'weekly';
    priorityLevel: 'low' | 'medium' | 'high' | 'critical';
    timeWindow: string; // cron expression
    maxConcurrency: number;
  };
}

export interface MarketplaceDataCollectionResult {
  jobId: string;
  tenantId: string;
  marketplace: MarketplaceType;
  status: 'completed' | 'partial' | 'failed' | 'in_progress';
  collectedData: {
    products: CollectedProductData[];
    priceUpdates: CollectedPriceData[];
    marketplaceMetrics: MarketplaceMetrics;
  };
  dataQuality: {
    overallScore: number;
    completeness: number;
    accuracy: number;
    freshness: number;
    reliability: number;
  };
  processingStats: {
    totalRequests: number;
    successfulRequests: number;
    failedRequests: number;
    rateLimitHits: number;
    avgResponseTime: number;
    dataProcessingTime: number;
  };
  errors: DataCollectionError[];
  warnings: string[];
  nextCollectionTime?: string;
}

export interface CollectedProductData {
  externalProductId: string;
  marketplace: MarketplaceType;
  name: string;
  description?: string;
  brand?: string;
  category?: string;
  currentPrice: number;
  originalPrice?: number;
  discountPercent?: number;
  stockQuantity?: number;
  rating?: number;
  reviewCount?: number;
  soldCount?: number;
  viewCount?: number;
  seller: {
    id: string;
    name: string;
    rating?: number;
    reviewCount?: number;
    location?: string;
    verified?: boolean;
  };
  shipping: {
    cost?: number;
    freeShippingThreshold?: number;
    deliveryTime?: number;
    methods?: string[];
    coverage?: string[];
  };
  images: {
    primary?: string;
    gallery?: string[];
    videos?: string[];
  };
  variants?: Array<{
    name: string;
    value: string;
    price?: number;
    stock?: number;
    sku?: string;
  }>;
  attributes?: Record<string, any>;
  marketplace_specific: {
    url: string;
    lastScraped: string;
    scrapingMethod: string;
    dataSource: string;
    rawData?: Record<string, any>;
  };
  indonesian_context: {
    region?: string;
    cities?: string[];
    businessLicense?: any;
    localShipping?: boolean;
    codSupport?: boolean;
    indonesianLanguage?: boolean;
  };
}

export interface CollectedPriceData {
  productId: string;
  marketplace: MarketplaceType;
  oldPrice?: number;
  newPrice: number;
  priceChange: number;
  priceChangePercent: number;
  eventType: PriceEventType;
  reason: PriceChangeReason;
  timestamp: string;
  stockChange?: {
    oldStock?: number;
    newStock?: number;
    inStock: boolean;
  };
  promotion?: {
    isActive: boolean;
    name?: string;
    startDate?: string;
    endDate?: string;
    discount?: number;
  };
  context: {
    marketPosition?: number;
    competitorPriceRange?: {
      min: number;
      max: number;
      average: number;
    };
    dataQuality: DataQuality;
    confidence: number;
  };
}

export interface MarketplaceMetrics {
  marketplace: MarketplaceType;
  categoryTrends: Record<string, {
    productCount: number;
    averagePrice: number;
    priceRange: { min: number; max: number };
    topBrands: string[];
    competitiveIntensity: number;
  }>;
  platformActivity: {
    newListings: number;
    priceChanges: number;
    promotions: number;
    stockouts: number;
    ratingsUpdates: number;
  };
  performanceMetrics: {
    responseTime: number;
    successRate: number;
    dataFreshness: number;
    coverageRate: number;
  };
  regionalInsights: Record<string, {
    productAvailability: number;
    averageShippingCost: number;
    deliveryTime: number;
    popularPaymentMethods: string[];
  }>;
}

export interface DataCollectionError {
  type: 'network' | 'parsing' | 'rate_limit' | 'auth' | 'data_quality' | 'unknown';
  productId?: string;
  marketplace: MarketplaceType;
  message: string;
  timestamp: string;
  details?: any;
  recoverable: boolean;
  retryCount: number;
}

// Marketplace-specific interfaces
export interface TokopediaProductData {
  product_id: string;
  product_name: string;
  product_price: number;
  product_original_price?: number;
  product_discount?: number;
  product_rating: number;
  product_sold: number;
  product_review_count: number;
  shop_id: string;
  shop_name: string;
  shop_location: string;
  shop_rating: number;
  category_name: string;
  product_images: string[];
  shipping_info: any;
  variants?: any[];
  specifications?: any;
}

export interface ShopeeProductData {
  itemid: number;
  shopid: number;
  name: string;
  price: number;
  price_before_discount?: number;
  discount?: string;
  rating_star: number;
  sold: number;
  historical_sold: number;
  view_count: number;
  shop_location: string;
  item_rating: {
    rating_star: number;
    rating_count: [number, number, number, number, number, number];
  };
  images: string[];
  attributes?: any[];
  models?: any[];
}

export interface LazadaProductData {
  nid: string;
  name: string;
  price: string;
  originalPrice?: string;
  discount?: string;
  ratingScore: number;
  review: number;
  itemSoldCntShow: string;
  sellerName: string;
  location: string;
  image: string;
  images?: string[];
  thumbs?: string[];
  skus?: any[];
  categories?: string[];
}

@Injectable()
export class MarketplaceDataCollectionService {
  private readonly logger = new Logger(MarketplaceDataCollectionService.name);
  private readonly userAgent = new UserAgent();

  constructor(
    @InjectRepository(CompetitiveProduct)
    private competitiveProductRepository: Repository<CompetitiveProduct>,
    
    @InjectRepository(CompetitivePriceHistory)
    private priceHistoryRepository: Repository<CompetitivePriceHistory>,
    
    @Inject(CACHE_MANAGER)
    private cacheManager: Cache,
    
    private eventEmitter: EventEmitter2,
    private configService: ConfigService,
  ) {}

  async collectMarketplaceData(request: MarketplaceDataCollectionRequest): Promise<MarketplaceDataCollectionResult> {
    const jobId = `collection_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    
    this.logger.log(`Starting marketplace data collection job: ${jobId} for ${request.marketplace}`);

    try {
      const result: MarketplaceDataCollectionResult = {
        jobId,
        tenantId: request.tenantId,
        marketplace: request.marketplace,
        status: 'in_progress',
        collectedData: {
          products: [],
          priceUpdates: [],
          marketplaceMetrics: {} as MarketplaceMetrics,
        },
        dataQuality: {
          overallScore: 0,
          completeness: 0,
          accuracy: 0,
          freshness: 0,
          reliability: 0,
        },
        processingStats: {
          totalRequests: 0,
          successfulRequests: 0,
          failedRequests: 0,
          rateLimitHits: 0,
          avgResponseTime: 0,
          dataProcessingTime: 0,
        },
        errors: [],
        warnings: [],
      };

      const startTime = Date.now();

      // Route to marketplace-specific collection method
      switch (request.marketplace) {
        case MarketplaceType.TOKOPEDIA:
          await this.collectTokopediaData(request, result);
          break;
        case MarketplaceType.SHOPEE:
          await this.collectShopeeData(request, result);
          break;
        case MarketplaceType.LAZADA:
          await this.collectLazadaData(request, result);
          break;
        case MarketplaceType.BUKALAPAK:
          await this.collectBukalapakData(request, result);
          break;
        case MarketplaceType.BLIBLI:
          await this.collectBlibliData(request, result);
          break;
        default:
          throw new BadRequestException(`Marketplace ${request.marketplace} not supported yet`);
      }

      // Calculate processing time and data quality
      result.processingStats.dataProcessingTime = Date.now() - startTime;
      result.dataQuality = this.calculateDataQuality(result);
      result.status = this.determineJobStatus(result);

      // Store collection results
      await this.storeCollectionResults(request.tenantId, result);
      
      // Emit collection completed event
      this.eventEmitter.emit('marketplace.data.collected', {
        tenantId: request.tenantId,
        marketplace: request.marketplace,
        jobId,
        status: result.status,
        productsCollected: result.collectedData.products.length,
        dataQuality: result.dataQuality.overallScore,
      });

      this.logger.log(`Marketplace data collection completed: ${jobId}, status: ${result.status}`);
      return result;

    } catch (error) {
      this.logger.error(`Marketplace data collection failed: ${error.message}`, error.stack);
      
      return {
        jobId,
        tenantId: request.tenantId,
        marketplace: request.marketplace,
        status: 'failed',
        collectedData: { products: [], priceUpdates: [], marketplaceMetrics: {} as MarketplaceMetrics },
        dataQuality: { overallScore: 0, completeness: 0, accuracy: 0, freshness: 0, reliability: 0 },
        processingStats: { totalRequests: 0, successfulRequests: 0, failedRequests: 1, rateLimitHits: 0, avgResponseTime: 0, dataProcessingTime: 0 },
        errors: [{
          type: 'unknown',
          marketplace: request.marketplace,
          message: error.message,
          timestamp: new Date().toISOString(),
          recoverable: false,
          retryCount: 0,
        }],
        warnings: [],
      };
    }
  }

  private async collectTokopediaData(
    request: MarketplaceDataCollectionRequest,
    result: MarketplaceDataCollectionResult,
  ): Promise<void> {
    this.logger.log('Starting Tokopedia data collection');

    const baseUrl = 'https://www.tokopedia.com';
    const apiUrl = 'https://gql.tokopedia.com/graphql';

    try {
      if (request.collectionType === 'product_details' && request.targets.productIds) {
        for (const productId of request.targets.productIds) {
          try {
            const productData = await this.scrapeTokopediaProduct(productId);
            if (productData) {
              const collectedProduct = this.transformTokopediaData(productData);
              result.collectedData.products.push(collectedProduct);
              result.processingStats.successfulRequests++;
            }
          } catch (error) {
            this.logger.error(`Failed to collect Tokopedia product ${productId}: ${error.message}`);
            result.errors.push({
              type: 'parsing',
              productId,
              marketplace: MarketplaceType.TOKOPEDIA,
              message: error.message,
              timestamp: new Date().toISOString(),
              recoverable: true,
              retryCount: 0,
            });
            result.processingStats.failedRequests++;
          }
          
          result.processingStats.totalRequests++;
          
          // Rate limiting untuk menghindari blocking
          if (request.collectionConfig.respectRateLimit) {
            await this.delay(1000 + Math.random() * 2000); // 1-3 detik delay
          }
        }
      }

      if (request.collectionType === 'competitor_discovery' && request.targets.searchQueries) {
        for (const query of request.targets.searchQueries) {
          try {
            const searchResults = await this.searchTokopediaProducts(query, request.collectionConfig.maxResults);
            for (const product of searchResults) {
              const collectedProduct = this.transformTokopediaData(product);
              result.collectedData.products.push(collectedProduct);
            }
            result.processingStats.successfulRequests++;
          } catch (error) {
            this.logger.error(`Failed to search Tokopedia for "${query}": ${error.message}`);
            result.errors.push({
              type: 'network',
              marketplace: MarketplaceType.TOKOPEDIA,
              message: `Search failed for query: ${query}`,
              timestamp: new Date().toISOString(),
              recoverable: true,
              retryCount: 0,
            });
            result.processingStats.failedRequests++;
          }
          
          result.processingStats.totalRequests++;
          
          if (request.collectionConfig.respectRateLimit) {
            await this.delay(2000 + Math.random() * 3000); // 2-5 detik untuk search
          }
        }
      }

      // Generate marketplace metrics
      result.collectedData.marketplaceMetrics = this.generateMarketplaceMetrics(
        MarketplaceType.TOKOPEDIA,
        result.collectedData.products,
      );

    } catch (error) {
      this.logger.error(`Tokopedia data collection error: ${error.message}`, error.stack);
      throw error;
    }
  }

  private async collectShopeeData(
    request: MarketplaceDataCollectionRequest,
    result: MarketplaceDataCollectionResult,
  ): Promise<void> {
    this.logger.log('Starting Shopee data collection');

    const baseUrl = 'https://shopee.co.id';
    const apiUrl = 'https://shopee.co.id/api/v4';

    try {
      if (request.collectionType === 'product_details' && request.targets.productIds) {
        for (const productId of request.targets.productIds) {
          try {
            const [shopId, itemId] = productId.split('-');
            const productData = await this.scrapeShopeeProduct(parseInt(shopId), parseInt(itemId));
            if (productData) {
              const collectedProduct = this.transformShopeeData(productData);
              result.collectedData.products.push(collectedProduct);
              result.processingStats.successfulRequests++;
            }
          } catch (error) {
            this.logger.error(`Failed to collect Shopee product ${productId}: ${error.message}`);
            result.errors.push({
              type: 'parsing',
              productId,
              marketplace: MarketplaceType.SHOPEE,
              message: error.message,
              timestamp: new Date().toISOString(),
              recoverable: true,
              retryCount: 0,
            });
            result.processingStats.failedRequests++;
          }
          
          result.processingStats.totalRequests++;
          
          if (request.collectionConfig.respectRateLimit) {
            await this.delay(1500 + Math.random() * 2500); // 1.5-4 detik delay
          }
        }
      }

      if (request.collectionType === 'competitor_discovery' && request.targets.searchQueries) {
        for (const query of request.targets.searchQueries) {
          try {
            const searchResults = await this.searchShopeeProducts(query, request.collectionConfig.maxResults);
            for (const product of searchResults) {
              const collectedProduct = this.transformShopeeData(product);
              result.collectedData.products.push(collectedProduct);
            }
            result.processingStats.successfulRequests++;
          } catch (error) {
            this.logger.error(`Failed to search Shopee for "${query}": ${error.message}`);
            result.errors.push({
              type: 'network',
              marketplace: MarketplaceType.SHOPEE,
              message: `Search failed for query: ${query}`,
              timestamp: new Date().toISOString(),
              recoverable: true,
              retryCount: 0,
            });
            result.processingStats.failedRequests++;
          }
          
          result.processingStats.totalRequests++;
          
          if (request.collectionConfig.respectRateLimit) {
            await this.delay(2500 + Math.random() * 3500); // 2.5-6 detik untuk search
          }
        }
      }

      result.collectedData.marketplaceMetrics = this.generateMarketplaceMetrics(
        MarketplaceType.SHOPEE,
        result.collectedData.products,
      );

    } catch (error) {
      this.logger.error(`Shopee data collection error: ${error.message}`, error.stack);
      throw error;
    }
  }

  private async collectLazadaData(
    request: MarketplaceDataCollectionRequest,
    result: MarketplaceDataCollectionResult,
  ): Promise<void> {
    this.logger.log('Starting Lazada data collection');

    try {
      if (request.collectionType === 'product_details' && request.targets.productIds) {
        for (const productId of request.targets.productIds) {
          try {
            const productData = await this.scrapeLazadaProduct(productId);
            if (productData) {
              const collectedProduct = this.transformLazadaData(productData);
              result.collectedData.products.push(collectedProduct);
              result.processingStats.successfulRequests++;
            }
          } catch (error) {
            this.logger.error(`Failed to collect Lazada product ${productId}: ${error.message}`);
            result.errors.push({
              type: 'parsing',
              productId,
              marketplace: MarketplaceType.LAZADA,
              message: error.message,
              timestamp: new Date().toISOString(),
              recoverable: true,
              retryCount: 0,
            });
            result.processingStats.failedRequests++;
          }
          
          result.processingStats.totalRequests++;
          
          if (request.collectionConfig.respectRateLimit) {
            await this.delay(2000 + Math.random() * 3000); // 2-5 detik delay
          }
        }
      }

      // For search queries
      if (request.collectionType === 'competitor_discovery' && request.targets.searchQueries) {
        for (const query of request.targets.searchQueries) {
          try {
            const searchResults = await this.searchLazadaProducts(query, request.collectionConfig.maxResults);
            for (const product of searchResults) {
              const collectedProduct = this.transformLazadaData(product);
              result.collectedData.products.push(collectedProduct);
            }
            result.processingStats.successfulRequests++;
          } catch (error) {
            this.logger.error(`Failed to search Lazada for "${query}": ${error.message}`);
            result.errors.push({
              type: 'network',
              marketplace: MarketplaceType.LAZADA,
              message: `Search failed for query: ${query}`,
              timestamp: new Date().toISOString(),
              recoverable: true,
              retryCount: 0,
            });
            result.processingStats.failedRequests++;
          }
          
          result.processingStats.totalRequests++;
          
          if (request.collectionConfig.respectRateLimit) {
            await this.delay(3000 + Math.random() * 4000); // 3-7 detik untuk search
          }
        }
      }

      result.collectedData.marketplaceMetrics = this.generateMarketplaceMetrics(
        MarketplaceType.LAZADA,
        result.collectedData.products,
      );

    } catch (error) {
      this.logger.error(`Lazada data collection error: ${error.message}`, error.stack);
      throw error;
    }
  }

  private async collectBukalapakData(
    request: MarketplaceDataCollectionRequest,
    result: MarketplaceDataCollectionResult,
  ): Promise<void> {
    this.logger.log('Starting Bukalapak data collection');
    
    // Placeholder implementation - akan dikembangkan sesuai API Bukalapak
    result.warnings.push('Bukalapak data collection is currently in development');
  }

  private async collectBlibliData(
    request: MarketplaceDataCollectionRequest,
    result: MarketplaceDataCollectionResult,
  ): Promise<void> {
    this.logger.log('Starting Blibli data collection');
    
    // Placeholder implementation - akan dikembangkan sesuai API Blibli
    result.warnings.push('Blibli data collection is currently in development');
  }

  // Tokopedia-specific scraping methods
  private async scrapeTokopediaProduct(productId: string): Promise<TokopediaProductData | null> {
    try {
      const url = `https://www.tokopedia.com/p/${productId}`;
      const response = await this.makeHttpRequest(url, {
        headers: {
          'User-Agent': this.userAgent.toString(),
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
          'Accept-Language': 'id-ID,id;q=0.9,en;q=0.8',
          'Accept-Encoding': 'gzip, deflate, br',
          'Connection': 'keep-alive',
          'Upgrade-Insecure-Requests': '1',
        },
      });

      const $ = cheerio.load(response.data);
      
      // Extract product data from Tokopedia page structure
      const productData: TokopediaProductData = {
        product_id: productId,
        product_name: $('h1[data-testid="lblPDPDetailProductName"]').text().trim(),
        product_price: this.parsePrice($('div[data-testid="lblPDPDetailProductPrice"]').text()),
        product_original_price: this.parsePrice($('div[data-testid="lblPDPDetailProductOriginalPrice"]').text()),
        product_rating: parseFloat($('span[data-testid="lblPDPDetailProductRatingNumber"]').text()) || 0,
        product_sold: this.parseNumber($('span[data-testid="lblPDPDetailProductSoldCounter"]').text()),
        product_review_count: this.parseNumber($('span[data-testid="lblPDPDetailProductReviewCounter"]').text()),
        shop_id: this.extractShopId($),
        shop_name: $('a[data-testid="llbPDPFooterShopName"]').text().trim(),
        shop_location: $('span[data-testid="lblPDPFooterShopLoc"]').text().trim(),
        shop_rating: parseFloat($('span[data-testid="lblPDPFooterShopRating"]').text()) || 0,
        category_name: this.extractCategory($),
        product_images: this.extractImages($),
        shipping_info: this.extractShippingInfo($),
        variants: this.extractVariants($),
        specifications: this.extractSpecifications($),
      };

      return productData;
    } catch (error) {
      this.logger.error(`Failed to scrape Tokopedia product ${productId}: ${error.message}`);
      return null;
    }
  }

  private async searchTokopediaProducts(query: string, maxResults: number): Promise<TokopediaProductData[]> {
    try {
      const encodedQuery = encodeURIComponent(query);
      const url = `https://www.tokopedia.com/search?st=product&q=${encodedQuery}&srp_component_id=02.01.00.00`;
      
      const response = await this.makeHttpRequest(url, {
        headers: {
          'User-Agent': this.userAgent.toString(),
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
          'Accept-Language': 'id-ID,id;q=0.9,en;q=0.8',
        },
      });

      const $ = cheerio.load(response.data);
      const products: TokopediaProductData[] = [];

      $('div[data-testid="master-product-card"]').each((index, element) => {
        if (index >= maxResults) return false;

        const $product = $(element);
        const productLink = $product.find('a').attr('href');
        const productId = this.extractProductIdFromUrl(productLink || '');

        if (productId) {
          const productData: TokopediaProductData = {
            product_id: productId,
            product_name: $product.find('span[data-testid="spnSRPProdName"]').text().trim(),
            product_price: this.parsePrice($product.find('span[data-testid="spnSRPProdPrice"]').text()),
            product_rating: parseFloat($product.find('span[data-testid="spnSRPProdRating"]').text()) || 0,
            product_sold: this.parseNumber($product.find('span[data-testid="spnSRPProdCountSold"]').text()),
            product_review_count: 0, // Not available in search results
            shop_id: '',
            shop_name: $product.find('span[data-testid="spnSRPProdTabShopLoc"]').text().trim(),
            shop_location: '',
            shop_rating: 0,
            category_name: '',
            product_images: [$product.find('img').attr('src') || ''].filter(Boolean),
            shipping_info: {},
          };

          products.push(productData);
        }
      });

      return products;
    } catch (error) {
      this.logger.error(`Failed to search Tokopedia for "${query}": ${error.message}`);
      return [];
    }
  }

  // Shopee-specific scraping methods
  private async scrapeShopeeProduct(shopId: number, itemId: number): Promise<ShopeeProductData | null> {
    try {
      const url = `https://shopee.co.id/api/v4/item/get?itemid=${itemId}&shopid=${shopId}`;
      
      const response = await this.makeHttpRequest(url, {
        headers: {
          'User-Agent': this.userAgent.toString(),
          'Accept': 'application/json',
          'Accept-Language': 'id-ID,id;q=0.9,en;q=0.8',
          'Referer': `https://shopee.co.id/product/${shopId}/${itemId}`,
          'X-Requested-With': 'XMLHttpRequest',
        },
      });

      if (response.data && response.data.item) {
        const item = response.data.item;
        
        const productData: ShopeeProductData = {
          itemid: item.itemid,
          shopid: item.shopid,
          name: item.name,
          price: item.price / 100000, // Shopee stores price in units of 10^-5
          price_before_discount: item.price_before_discount ? item.price_before_discount / 100000 : undefined,
          discount: item.discount,
          rating_star: item.item_rating?.rating_star || 0,
          sold: item.sold || 0,
          historical_sold: item.historical_sold || 0,
          view_count: item.view_count || 0,
          shop_location: item.shop_location || '',
          item_rating: item.item_rating || { rating_star: 0, rating_count: [0, 0, 0, 0, 0, 0] },
          images: item.images?.map((img: string) => `https://cf.shopee.co.id/file/${img}`) || [],
          attributes: item.attributes || [],
          models: item.models || [],
        };

        return productData;
      }

      return null;
    } catch (error) {
      this.logger.error(`Failed to scrape Shopee product ${shopId}-${itemId}: ${error.message}`);
      return null;
    }
  }

  private async searchShopeeProducts(query: string, maxResults: number): Promise<ShopeeProductData[]> {
    try {
      const encodedQuery = encodeURIComponent(query);
      const url = `https://shopee.co.id/api/v4/search/search_items?keyword=${encodedQuery}&limit=${maxResults}&newest=0&order=relevancy&page_type=search&scenario=PAGE_GLOBAL_SEARCH&version=2`;
      
      const response = await this.makeHttpRequest(url, {
        headers: {
          'User-Agent': this.userAgent.toString(),
          'Accept': 'application/json',
          'Accept-Language': 'id-ID,id;q=0.9,en;q=0.8',
          'Referer': `https://shopee.co.id/search?keyword=${encodedQuery}`,
        },
      });

      if (response.data && response.data.items) {
        return response.data.items.map((item: any) => ({
          itemid: item.itemid,
          shopid: item.shopid,
          name: item.name,
          price: item.price / 100000,
          price_before_discount: item.price_before_discount ? item.price_before_discount / 100000 : undefined,
          discount: item.discount,
          rating_star: item.item_rating?.rating_star || 0,
          sold: item.sold || 0,
          historical_sold: item.historical_sold || 0,
          view_count: item.view_count || 0,
          shop_location: item.shop_location || '',
          item_rating: item.item_rating || { rating_star: 0, rating_count: [0, 0, 0, 0, 0, 0] },
          images: item.images?.map((img: string) => `https://cf.shopee.co.id/file/${img}`) || [],
        }));
      }

      return [];
    } catch (error) {
      this.logger.error(`Failed to search Shopee for "${query}": ${error.message}`);
      return [];
    }
  }

  // Lazada-specific scraping methods
  private async scrapeLazadaProduct(productId: string): Promise<LazadaProductData | null> {
    try {
      // Lazada menggunakan struktur URL yang berbeda
      const url = `https://www.lazada.co.id/products/${productId}.html`;
      
      const response = await this.makeHttpRequest(url, {
        headers: {
          'User-Agent': this.userAgent.toString(),
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
          'Accept-Language': 'id-ID,id;q=0.9,en;q=0.8',
        },
      });

      const $ = cheerio.load(response.data);
      
      // Extract data dari JSON yang di-embed di halaman
      const scriptTags = $('script').toArray();
      let productData: LazadaProductData | null = null;

      for (const script of scriptTags) {
        const scriptContent = $(script).html();
        if (scriptContent && scriptContent.includes('__LZD__')) {
          try {
            // Parse embedded JSON data
            const jsonMatch = scriptContent.match(/window\.pageData\s*=\s*({.*?});/);
            if (jsonMatch) {
              const pageData = JSON.parse(jsonMatch[1]);
              const product = pageData.mods?.product;
              
              if (product) {
                productData = {
                  nid: product.nid || productId,
                  name: product.name,
                  price: product.price?.salePrice?.text || product.price?.originalPrice?.text || '0',
                  originalPrice: product.price?.originalPrice?.text,
                  discount: product.price?.discount,
                  ratingScore: product.review?.rating || 0,
                  review: product.review?.count || 0,
                  itemSoldCntShow: product.quantity?.sold || '0',
                  sellerName: product.seller?.name || '',
                  location: product.seller?.location || '',
                  image: product.images?.[0] || '',
                  images: product.images || [],
                  skus: product.skus || [],
                  categories: product.categories || [],
                };
                break;
              }
            }
          } catch (parseError) {
            this.logger.warn(`Failed to parse Lazada JSON data: ${parseError.message}`);
          }
        }
      }

      return productData;
    } catch (error) {
      this.logger.error(`Failed to scrape Lazada product ${productId}: ${error.message}`);
      return null;
    }
  }

  private async searchLazadaProducts(query: string, maxResults: number): Promise<LazadaProductData[]> {
    try {
      const encodedQuery = encodeURIComponent(query);
      const url = `https://www.lazada.co.id/catalog/?q=${encodedQuery}&_keyori=ss&from=input&spm=a2o4j.searchlistcategory.search.go.74e53819W8bP3q`;
      
      const response = await this.makeHttpRequest(url, {
        headers: {
          'User-Agent': this.userAgent.toString(),
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
          'Accept-Language': 'id-ID,id;q=0.9,en;q=0.8',
        },
      });

      const $ = cheerio.load(response.data);
      const products: LazadaProductData[] = [];

      // Lazada menggunakan JSON data yang di-embed
      const scriptTags = $('script').toArray();
      
      for (const script of scriptTags) {
        const scriptContent = $(script).html();
        if (scriptContent && scriptContent.includes('window.pageData')) {
          try {
            const jsonMatch = scriptContent.match(/window\.pageData\s*=\s*({.*?});/);
            if (jsonMatch) {
              const pageData = JSON.parse(jsonMatch[1]);
              const productList = pageData.mods?.listItems;
              
              if (productList && Array.isArray(productList)) {
                productList.slice(0, maxResults).forEach((product: any) => {
                  products.push({
                    nid: product.nid,
                    name: product.name,
                    price: product.priceShow,
                    originalPrice: product.originalPriceShow,
                    discount: product.discount,
                    ratingScore: product.ratingScore || 0,
                    review: product.review || 0,
                    itemSoldCntShow: product.itemSoldCntShow || '0',
                    sellerName: product.sellerName || '',
                    location: product.location || '',
                    image: product.image,
                    images: [product.image],
                  });
                });
                break;
              }
            }
          } catch (parseError) {
            this.logger.warn(`Failed to parse Lazada search JSON: ${parseError.message}`);
          }
        }
      }

      return products;
    } catch (error) {
      this.logger.error(`Failed to search Lazada for "${query}": ${error.message}`);
      return [];
    }
  }

  // Data transformation methods
  private transformTokopediaData(data: TokopediaProductData): CollectedProductData {
    return {
      externalProductId: data.product_id,
      marketplace: MarketplaceType.TOKOPEDIA,
      name: data.product_name,
      brand: this.extractBrandFromName(data.product_name),
      category: data.category_name,
      currentPrice: data.product_price,
      originalPrice: data.product_original_price,
      discountPercent: data.product_original_price && data.product_price
        ? ((data.product_original_price - data.product_price) / data.product_original_price) * 100
        : undefined,
      rating: data.product_rating,
      reviewCount: data.product_review_count,
      soldCount: data.product_sold,
      seller: {
        id: data.shop_id,
        name: data.shop_name,
        rating: data.shop_rating,
        location: data.shop_location,
      },
      shipping: {
        cost: data.shipping_info?.cost,
        methods: data.shipping_info?.methods,
      },
      images: {
        primary: data.product_images?.[0],
        gallery: data.product_images,
      },
      variants: data.variants?.map(v => ({
        name: v.name,
        value: v.value,
        price: v.price,
        stock: v.stock,
      })),
      attributes: data.specifications,
      marketplace_specific: {
        url: `https://www.tokopedia.com/p/${data.product_id}`,
        lastScraped: new Date().toISOString(),
        scrapingMethod: 'html_parsing',
        dataSource: 'tokopedia_website',
        rawData: data,
      },
      indonesian_context: {
        region: this.extractRegionFromLocation(data.shop_location),
        localShipping: true,
        codSupport: true,
        indonesianLanguage: true,
      },
    };
  }

  private transformShopeeData(data: ShopeeProductData): CollectedProductData {
    return {
      externalProductId: `${data.shopid}-${data.itemid}`,
      marketplace: MarketplaceType.SHOPEE,
      name: data.name,
      brand: this.extractBrandFromName(data.name),
      currentPrice: data.price,
      originalPrice: data.price_before_discount,
      discountPercent: data.discount ? parseFloat(data.discount.replace('%', '')) : undefined,
      rating: data.rating_star,
      reviewCount: data.item_rating.rating_count.reduce((sum, count) => sum + count, 0),
      soldCount: data.sold,
      viewCount: data.view_count,
      seller: {
        id: data.shopid.toString(),
        name: '',
        location: data.shop_location,
      },
      images: {
        primary: data.images?.[0],
        gallery: data.images,
      },
      variants: data.models?.map(model => ({
        name: model.name,
        value: model.name,
        price: model.price / 100000,
        stock: model.stock,
      })),
      attributes: data.attributes?.reduce((acc, attr) => {
        acc[attr.name] = attr.value;
        return acc;
      }, {} as Record<string, any>),
      marketplace_specific: {
        url: `https://shopee.co.id/product/${data.shopid}/${data.itemid}`,
        lastScraped: new Date().toISOString(),
        scrapingMethod: 'api_call',
        dataSource: 'shopee_api',
        rawData: data,
      },
      indonesian_context: {
        region: this.extractRegionFromLocation(data.shop_location),
        localShipping: true,
        codSupport: true,
        indonesianLanguage: true,
      },
    };
  }

  private transformLazadaData(data: LazadaProductData): CollectedProductData {
    return {
      externalProductId: data.nid,
      marketplace: MarketplaceType.LAZADA,
      name: data.name,
      brand: this.extractBrandFromName(data.name),
      category: data.categories?.[0],
      currentPrice: this.parsePrice(data.price),
      originalPrice: data.originalPrice ? this.parsePrice(data.originalPrice) : undefined,
      discountPercent: data.discount ? parseFloat(data.discount.replace('%', '')) : undefined,
      rating: data.ratingScore,
      reviewCount: data.review,
      soldCount: this.parseNumber(data.itemSoldCntShow),
      seller: {
        id: '',
        name: data.sellerName,
        location: data.location,
      },
      images: {
        primary: data.image,
        gallery: data.images,
      },
      variants: data.skus?.map(sku => ({
        name: sku.name || '',
        value: sku.value || '',
        price: sku.price,
        stock: sku.stock,
      })),
      marketplace_specific: {
        url: `https://www.lazada.co.id/products/${data.nid}.html`,
        lastScraped: new Date().toISOString(),
        scrapingMethod: 'html_parsing',
        dataSource: 'lazada_website',
        rawData: data,
      },
      indonesian_context: {
        region: this.extractRegionFromLocation(data.location),
        localShipping: true,
        codSupport: true,
        indonesianLanguage: true,
      },
    };
  }

  // Utility methods
  private async makeHttpRequest(url: string, options: any = {}): Promise<AxiosResponse> {
    const defaultOptions = {
      timeout: 30000,
      maxRedirects: 5,
      validateStatus: (status: number) => status < 500,
    };

    const config = { ...defaultOptions, ...options };
    
    try {
      const response = await axios.get(url, config);
      
      if (response.status === 429) {
        this.logger.warn(`Rate limit hit for URL: ${url}`);
        throw new Error('Rate limit exceeded');
      }
      
      if (response.status >= 400) {
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      }
      
      return response;
    } catch (error) {
      this.logger.error(`HTTP request failed for ${url}: ${error.message}`);
      throw error;
    }
  }

  private parsePrice(priceString: string): number {
    if (!priceString) return 0;
    
    // Remove Indonesian price formatting
    const cleanPrice = priceString
      .replace(/[Rp\s.]/g, '') // Remove Rp, spaces, and dots
      .replace(/,/g, '.'); // Replace comma with dot for decimal
    
    return parseFloat(cleanPrice) || 0;
  }

  private parseNumber(numberString: string): number {
    if (!numberString) return 0;
    
    const cleanNumber = numberString
      .replace(/[^\d.,]/g, '') // Keep only digits, commas, and dots
      .replace(/\./g, '') // Remove thousand separators
      .replace(/,/g, '.'); // Replace comma with dot for decimal
    
    return parseFloat(cleanNumber) || 0;
  }

  private extractBrandFromName(productName: string): string {
    // Simple brand extraction logic - can be enhanced with ML
    const words = productName.split(' ');
    return words[0] || '';
  }

  private extractRegionFromLocation(location: string): string {
    if (!location) return '';
    
    // Map common Indonesian city/province names to regions
    const regionMapping: Record<string, string> = {
      'Jakarta': 'Java',
      'Surabaya': 'Java',
      'Bandung': 'Java',
      'Semarang': 'Java',
      'Medan': 'Sumatra',
      'Palembang': 'Sumatra',
      'Makassar': 'Sulawesi',
      'Denpasar': 'Bali',
      'Banjarmasin': 'Kalimantan',
    };

    for (const [city, region] of Object.entries(regionMapping)) {
      if (location.includes(city)) {
        return region;
      }
    }

    return 'Unknown';
  }

  private extractShopId($: cheerio.CheerioAPI): string {
    // Implementation to extract shop ID from Tokopedia page
    const shopLink = $('a[data-testid="llbPDPFooterShopName"]').attr('href');
    if (shopLink) {
      const match = shopLink.match(/\/([^\/]+)$/);
      return match ? match[1] : '';
    }
    return '';
  }

  private extractCategory($: cheerio.CheerioAPI): string {
    // Extract category from breadcrumb
    const breadcrumb = $('nav[data-testid="breadcrumb"]');
    const categoryLinks = breadcrumb.find('a');
    return categoryLinks.last().text().trim();
  }

  private extractImages($: cheerio.CheerioAPI): string[] {
    const images: string[] = [];
    $('img[data-testid="PDPImageMain"], img[data-testid="PDPImageThumbnail"]').each((_, img) => {
      const src = $(img).attr('src');
      if (src) images.push(src);
    });
    return [...new Set(images)]; // Remove duplicates
  }

  private extractShippingInfo($: cheerio.CheerioAPI): any {
    return {
      cost: this.parsePrice($('span[data-testid="lblPDPDetailProductShippingCost"]').text()),
      methods: [], // Would need more detailed parsing
    };
  }

  private extractVariants($: cheerio.CheerioAPI): any[] {
    const variants: any[] = [];
    $('button[data-testid="btnPDPDetailProductVariant"]').each((_, variant) => {
      const $variant = $(variant);
      variants.push({
        name: $variant.find('span').text().trim(),
        value: $variant.attr('data-value') || '',
      });
    });
    return variants;
  }

  private extractSpecifications($: cheerio.CheerioAPI): any {
    const specs: any = {};
    $('table[data-testid="lblPDPDetailProductSpecs"] tr').each((_, row) => {
      const $row = $(row);
      const key = $row.find('td').first().text().trim();
      const value = $row.find('td').last().text().trim();
      if (key && value) {
        specs[key] = value;
      }
    });
    return specs;
  }

  private extractProductIdFromUrl(url: string): string {
    // Extract product ID from Tokopedia URL
    const match = url.match(/\/p\/([^\/\?]+)/);
    return match ? match[1] : '';
  }

  private generateMarketplaceMetrics(
    marketplace: MarketplaceType,
    products: CollectedProductData[],
  ): MarketplaceMetrics {
    const categoryTrends: Record<string, any> = {};
    let totalPrice = 0;
    let priceCount = 0;
    const brands = new Set<string>();

    products.forEach(product => {
      // Category analysis
      if (product.category) {
        if (!categoryTrends[product.category]) {
          categoryTrends[product.category] = {
            productCount: 0,
            totalPrice: 0,
            prices: [],
            brands: new Set(),
          };
        }
        
        categoryTrends[product.category].productCount++;
        categoryTrends[product.category].totalPrice += product.currentPrice;
        categoryTrends[product.category].prices.push(product.currentPrice);
        
        if (product.brand) {
          categoryTrends[product.category].brands.add(product.brand);
          brands.add(product.brand);
        }
      }

      totalPrice += product.currentPrice;
      priceCount++;
    });

    // Process category trends
    Object.keys(categoryTrends).forEach(category => {
      const trend = categoryTrends[category];
      const prices = trend.prices.sort((a: number, b: number) => a - b);
      
      categoryTrends[category] = {
        productCount: trend.productCount,
        averagePrice: trend.totalPrice / trend.productCount,
        priceRange: {
          min: prices[0] || 0,
          max: prices[prices.length - 1] || 0,
        },
        topBrands: Array.from(trend.brands).slice(0, 5),
        competitiveIntensity: Math.min(trend.productCount / 10, 1), // 0-1 scale
      };
    });

    return {
      marketplace,
      categoryTrends,
      platformActivity: {
        newListings: products.length,
        priceChanges: 0, // Would need historical data
        promotions: products.filter(p => p.discountPercent && p.discountPercent > 0).length,
        stockouts: 0, // Would need stock information
        ratingsUpdates: 0, // Would need historical data
      },
      performanceMetrics: {
        responseTime: 0, // Would be calculated during collection
        successRate: 1.0, // Would be calculated during collection
        dataFreshness: 1.0, // Data is fresh since just collected
        coverageRate: 1.0, // Would be calculated based on targets vs results
      },
      regionalInsights: {},
    };
  }

  private calculateDataQuality(result: MarketplaceDataCollectionResult): {
    overallScore: number;
    completeness: number;
    accuracy: number;
    freshness: number;
    reliability: number;
  } {
    const products = result.collectedData.products;
    const stats = result.processingStats;

    // Calculate completeness
    let completenessScore = 0;
    if (products.length > 0) {
      const totalFields = products.length * 10; // 10 key fields per product
      let completedFields = 0;
      
      products.forEach(product => {
        if (product.name) completedFields++;
        if (product.currentPrice > 0) completedFields++;
        if (product.seller.name) completedFields++;
        if (product.rating !== undefined) completedFields++;
        if (product.reviewCount !== undefined) completedFields++;
        if (product.soldCount !== undefined) completedFields++;
        if (product.images.primary) completedFields++;
        if (product.category) completedFields++;
        if (product.brand) completedFields++;
        if (product.marketplace_specific.url) completedFields++;
      });
      
      completenessScore = completedFields / totalFields;
    }

    // Calculate accuracy (based on error rate)
    const accuracyScore = stats.successfulRequests / Math.max(stats.totalRequests, 1);

    // Calculate freshness (all data is fresh since just collected)
    const freshnessScore = 1.0;

    // Calculate reliability (based on data quality indicators)
    const reliabilityScore = Math.max(0, 1 - (result.errors.length / Math.max(stats.totalRequests, 1)));

    // Overall score is weighted average
    const overallScore = (
      completenessScore * 0.3 +
      accuracyScore * 0.3 +
      freshnessScore * 0.2 +
      reliabilityScore * 0.2
    );

    return {
      overallScore: Math.round(overallScore * 100) / 100,
      completeness: Math.round(completenessScore * 100) / 100,
      accuracy: Math.round(accuracyScore * 100) / 100,
      freshness: Math.round(freshnessScore * 100) / 100,
      reliability: Math.round(reliabilityScore * 100) / 100,
    };
  }

  private determineJobStatus(result: MarketplaceDataCollectionResult): 'completed' | 'partial' | 'failed' {
    const { successfulRequests, failedRequests, totalRequests } = result.processingStats;
    
    if (totalRequests === 0) return 'failed';
    
    const successRate = successfulRequests / totalRequests;
    
    if (successRate >= 0.9) return 'completed';
    if (successRate >= 0.5) return 'partial';
    return 'failed';
  }

  private async storeCollectionResults(
    tenantId: string,
    result: MarketplaceDataCollectionResult,
  ): Promise<void> {
    try {
      // Store collected products in database
      for (const productData of result.collectedData.products) {
        await this.competitiveProductRepository.upsert({
          tenantId,
          externalProductId: productData.externalProductId,
          marketplace: productData.marketplace,
          name: productData.name,
          description: productData.description,
          brand: productData.brand,
          category: productData.category,
          currentPrice: productData.currentPrice,
          originalPrice: productData.originalPrice,
          discountPercent: productData.discountPercent,
          stockQuantity: productData.stockQuantity,
          rating: productData.rating,
          reviewCount: productData.reviewCount,
          soldCount: productData.soldCount,
          viewCount: productData.viewCount,
          sellerId: productData.seller.id,
          sellerName: productData.seller.name,
          sellerRating: productData.seller.rating,
          primaryImageUrl: productData.images.primary,
          imageUrls: productData.images.gallery,
          variants: productData.variants,
          attributes: productData.attributes,
          region: productData.indonesian_context.region,
          availableCities: productData.indonesian_context.cities,
          lastUpdated: new Date(),
          lastChecked: new Date(),
          dataQuality: this.mapDataQuality(result.dataQuality.overallScore),
          metadata: {
            collectionJobId: result.jobId,
            scrapingMethod: productData.marketplace_specific.scrapingMethod,
            dataSource: productData.marketplace_specific.dataSource,
          },
        }, ['tenantId', 'marketplace', 'externalProductId']);
      }

      // Store price updates in history
      for (const priceData of result.collectedData.priceUpdates) {
        await this.priceHistoryRepository.save({
          tenantId,
          competitiveProductId: priceData.productId,
          currentPrice: priceData.newPrice,
          previousPrice: priceData.oldPrice,
          priceChange: priceData.priceChange,
          priceChangePercent: priceData.priceChangePercent,
          eventType: priceData.eventType,
          priceChangeReason: priceData.reason,
          inStock: priceData.stockChange?.inStock ?? true,
          isPromotion: priceData.promotion?.isActive ?? false,
          promotionName: priceData.promotion?.name,
          detectionConfidence: priceData.context.confidence,
          dataReliability: this.mapDataQuality(priceData.context.dataQuality),
          hourOfDay: new Date().getHours(),
          dayOfWeek: new Date().getDay(),
          timezone: 'Asia/Jakarta',
          recordedAt: new Date(priceData.timestamp),
        });
      }

      // Cache collection results for quick access
      await this.cacheManager.set(
        `collection_result_${result.jobId}`,
        result,
        300, // 5 minutes
      );

      this.logger.log(`Stored collection results for job ${result.jobId}`);
      
    } catch (error) {
      this.logger.error(`Failed to store collection results: ${error.message}`, error.stack);
      throw error;
    }
  }

  private mapDataQuality(score: number): DataQuality {
    if (score >= 0.9) return DataQuality.HIGH;
    if (score >= 0.7) return DataQuality.MEDIUM;
    if (score >= 0.5) return DataQuality.LOW;
    return DataQuality.UNRELIABLE;
  }

  private async delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // Public methods for external API access
  async getCollectionJobStatus(jobId: string): Promise<MarketplaceDataCollectionResult | null> {
    try {
      const result = await this.cacheManager.get<MarketplaceDataCollectionResult>(`collection_result_${jobId}`);
      return result || null;
    } catch (error) {
      this.logger.error(`Failed to get collection job status: ${error.message}`);
      return null;
    }
  }

  async schedulePeriodicCollection(
    request: MarketplaceDataCollectionRequest,
  ): Promise<{ scheduleId: string; nextRun: string }> {
    // Placeholder for scheduling implementation
    // Would integrate with job scheduler like Bull or cron
    const scheduleId = `schedule_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const nextRun = moment().add(1, 'day').toISOString();

    this.logger.log(`Scheduled periodic collection: ${scheduleId} for ${request.marketplace}`);

    return { scheduleId, nextRun };
  }

  async getMarketplaceMetrics(
    tenantId: string,
    marketplace: MarketplaceType,
    timeRange?: { from: string; to: string },
  ): Promise<MarketplaceMetrics> {
    // Get metrics from stored data
    const products = await this.competitiveProductRepository.find({
      where: {
        tenantId,
        marketplace,
        lastUpdated: timeRange ? Between(new Date(timeRange.from), new Date(timeRange.to)) : undefined,
      },
    });

    const collectedProducts = products.map(p => this.mapToCollectedProductData(p));
    return this.generateMarketplaceMetrics(marketplace, collectedProducts);
  }

  private mapToCollectedProductData(product: CompetitiveProduct): CollectedProductData {
    return {
      externalProductId: product.externalProductId,
      marketplace: product.marketplace,
      name: product.name,
      description: product.description,
      brand: product.brand,
      category: product.category,
      currentPrice: Number(product.currentPrice),
      originalPrice: product.originalPrice ? Number(product.originalPrice) : undefined,
      discountPercent: product.discountPercent ? Number(product.discountPercent) : undefined,
      stockQuantity: product.stockQuantity,
      rating: product.rating ? Number(product.rating) : undefined,
      reviewCount: product.reviewCount,
      soldCount: product.soldCount,
      viewCount: product.viewCount,
      seller: {
        id: product.sellerId || '',
        name: product.sellerName || '',
        rating: product.sellerRating ? Number(product.sellerRating) : undefined,
        reviewCount: product.sellerReviewCount,
        location: product.region,
      },
      shipping: {
        cost: product.shippingCost ? Number(product.shippingCost) : undefined,
        freeShippingThreshold: product.freeShippingThreshold ? Number(product.freeShippingThreshold) : undefined,
        deliveryTime: product.deliveryTimeDays,
        methods: product.shippingMethods as string[],
      },
      images: {
        primary: product.primaryImageUrl,
        gallery: product.imageUrls as string[],
        videos: product.videoUrls as string[],
      },
      variants: product.variants as any[],
      attributes: product.attributes as Record<string, any>,
      marketplace_specific: {
        url: `${product.marketplace}://product/${product.externalProductId}`,
        lastScraped: product.lastUpdated?.toISOString() || '',
        scrapingMethod: (product.metadata as any)?.scrapingMethod || 'unknown',
        dataSource: (product.metadata as any)?.dataSource || 'unknown',
        rawData: product.metadata,
      },
      indonesian_context: {
        region: product.region,
        cities: product.availableCities as string[],
        businessLicense: product.businessLicense,
        localShipping: true,
        codSupport: true,
        indonesianLanguage: true,
      },
    };
  }
}